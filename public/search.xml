<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>leetcode 881 Boats to Save People</title>
    <url>/2019-11-29-leetcode-881-Boats-to-Save-People.html</url>
    <content><![CDATA[<h1 id="leetcode-881-Boats-to-Save-People"><a href="#leetcode-881-Boats-to-Save-People" class="headerlink" title="leetcode 881 Boats to Save People"></a>leetcode 881 Boats to Save People</h1><p><a href="https://leetcode.com/problems/boats-to-save-people/" target="_blank" rel="noopener">题目来源</a>。要求在船有载重量和人数限制为2的情况下，给出将所有人运过河的最小船数。</p>
<a id="more"></a>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用贪心算法，进行求解。</p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>首先是自己的思路：贪心的考虑每只船都尽可能的装满限重，然后优先让胖的人先上船，之后寻找在剩下载重量限制的情况下，找最胖的人。</p>
<p>在具体实现上，先遍历一遍人数的重量，按照重量进行桶排序，因为重量不会超过limit，而且都是整数所以是可以实现的。每个桶记录该重量下的人数，然后先将重量最大的给安排上船，并寻找能够匹配的第二个重量。直到最轻的被遍历完得到答案。</p>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>提交后发现网上的思路和自己有一点差别：配对的贪心规则是最胖的先走之后，选择最轻的进行匹配。这样就很容易的使用双指针来实现。不过为什么两种规则都能够过，自己还在思考中,参考链接中有对这种贪心规则的证明。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="桶排序-1"><a href="#桶排序-1" class="headerlink" title="桶排序"></a>桶排序</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/* 桶排序 贪心的选择最胖的先走</span></span><br><span class="line"><span class="comment">	Runtime: 96 ms</span></span><br><span class="line"><span class="comment">	Memory Usage: 16.5 MB*/</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; people, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = people.size();</span><br><span class="line">		<span class="keyword">if</span>(num&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">person</span><span class="params">(limit+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)&#123;</span><br><span class="line">            person[people[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// int crossed = 0;</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = limit; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=person[i]; j&gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				<span class="comment">// crossed++;</span></span><br><span class="line">				person[i]--;<span class="comment">// 运走一个人后 计数减1</span></span><br><span class="line">				<span class="keyword">int</span> rest = limit - i;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=rest; k&gt;<span class="number">0</span>; k--)&#123;</span><br><span class="line">					<span class="keyword">if</span>(person[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">						person[k]--;</span><br><span class="line">						<span class="keyword">if</span>(k==i) j--; <span class="comment">// 如果减去的和当前指向的weight一样 则需要减去自身</span></span><br><span class="line">						<span class="comment">// crossed++;</span></span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// if(crossed==num) cout&lt;&lt;"all crossed" &lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">return</span> ans;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是如果剩下的重量和当前重量一致的时候，迭代的计数也要减1，比如limit为4，当前迭代的重量为2，剩下的匹配重量也为2情况。</p>
<h3 id="双指针-1"><a href="#双指针-1" class="headerlink" title="双指针"></a>双指针</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">cpp</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*排序后 双指针</span></span><br><span class="line"><span class="comment">	Runtime: 116 ms</span></span><br><span class="line"><span class="comment">	Memory Usage: 13.6 MB</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; people, <span class="keyword">int</span> limit)</span></span>&#123;</span><br><span class="line">    	sort(people.begin(), people.end());</span><br><span class="line">    	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    	<span class="keyword">int</span> j = people.size() - <span class="number">1</span>;</span><br><span class="line">    	<span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">    		<span class="keyword">if</span>(people[i]+people[j]&lt;=limit)&#123;</span><br><span class="line">    			i++;</span><br><span class="line">    			j--;</span><br><span class="line">    			ans++;</span><br><span class="line">    		&#125;</span><br><span class="line">    		<span class="keyword">else</span>&#123;</span><br><span class="line">    			j--;</span><br><span class="line">    			ans++;</span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	<span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><p>leetcode上面显示桶排序的速度能够超过96%的提交，但是空间使用仅超过11%.</p>
<h3 id="桶排序-2"><a href="#桶排序-2" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序的时间复杂读为O(n)，但是空间消耗较多为O(limit)。自己实现的代码中虽然有三层for循环，但是每一层都不是人数n，从总的被遍历到的人来考虑，前面两层是遍历的人数因此是O(n)，而每一个重量的人都需要去寻找匹配的重量，考虑最坏的情况是O(limit)，但是一般来说不会寻找太多次，所以可以认为近似的是O(1)。因此总得时间复杂度为O(n)，空间复杂度为O(limit)</p>
<h3 id="双指针-2"><a href="#双指针-2" class="headerlink" title="双指针"></a>双指针</h3><p>双指针的时间复杂度为排序的时间复杂度，使用快排的话是O(nlogn)。不需要额外的空间，所以是O(1)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>对于第二种匹配规则的贪心的证明<a href="https://zhanghuimeng.github.io/post/leetcode-881-boats-to-save-people/" target="_blank" rel="noopener">参考</a> 但是存疑，因为我用第一种的匹配规则也做出来了。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode153 154 Find Minimum in Rotated Sorted Array I/II</title>
    <url>/2019-11-22-leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-III.html</url>
    <content><![CDATA[<h1 id="leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-I-II"><a href="#leetcode153-154-Find-Minimum-in-Rotated-Sorted-Array-I-II" class="headerlink" title="leetcode153 154. Find Minimum in Rotated Sorted Array I/II"></a>leetcode153 154. Find Minimum in Rotated Sorted Array I/II</h1><p>题目来源<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">leetcode153</a> 和<a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">leetcode154</a> 要求在排序的旋转数组中寻找最小值。最小值可以很简单的遍历一次数组得到，时间复杂度为$O(n)$但是没有用到题目给的性质，所以会超时。</p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="leetcode153-无重复元素"><a href="#leetcode153-无重复元素" class="headerlink" title="leetcode153 无重复元素"></a>leetcode153 无重复元素</h3><p>先分析leetcode153中没有重复值的情况，采用二分查找的思路，设输入的数组长度为n表示为$A[n]$,经过观察可以发现pivot将A划分成了两个递增子数组L，R。使用指针p指向A的第一个元素A[0],指针q指向A的最后一个元素$A[n-1]$,使用指针m指向A的中间元素$A[\frac{n}{2}]$。如果中间元素位于第一个递增数组L，则有关系：A[p]<a[m],a[m]>A[q],此时最小元素在m与q之间，将p移动到m，原来规模为n的问题变成规模为$q-m=\frac{n}{2}$的子问题。如果中间元素位于第二个递增数组R，则有关系：A[p]&gt;A[m],A[m]&lt;A[q],此时最小元素在p与m之间，将q移动到m，原来规模为n的问题变成规模为$m-p=\frac{n}{2}$的子问题。直到最后q=p+1时，问题规模下降到2的情况，得到答案最小的元素为q指针指向的元素。可以看到每一次迭代，都会将n规模的问题下降到$\frac{n}{2}$规模。</a[m],a[m]></p>
<h3 id="leetcode154-有重复元素"><a href="#leetcode154-有重复元素" class="headerlink" title="leetcode154 有重复元素"></a>leetcode154 有重复元素</h3><p>在有重复值的情况下，会出现$A[m]==A[p]$的情况，这个时候是无法判断到底左右两边谁为递增序列。如</p>
<script type="math/tex; mode=display">
[2, 2, 2, 2, 1,1,1, 2]</script><p>这时候的$A[m]==A[3]$与$A[p]==A[0]$是相等的都是2，所以只能把两边的最小值，递归的调用求解出来。</p>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><h3 id="leetcode153-无重复元素-1"><a href="#leetcode153-无重复元素-1" class="headerlink" title="leetcode153 无重复元素"></a>leetcode153 无重复元素</h3><p>可以画出递归图:</p>
<p><a href="https://res.cloudinary.com/bravey/image/upload/v1574430318/blog/coding/leetcode_153_reduction_graph.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://res.cloudinary.com/bravey/image/upload/v1574430318/blog/coding/leetcode_153_reduction_graph.jpg" class="lazyload"></a></p>
<p>用$T(n)​$表示对于一个长度为n的旋转数组进行查找最小值需要的次数，对于每一次迭代都有$T[n]=T[{\lfloor\frac{n}{2}\rfloor]+C}​$,C是一个常数。所以有</p>
<script type="math/tex; mode=display">
\begin{split}

T(n)&=T[{\lfloor\frac{n}{2}\rfloor]+C}\\

&=T[{\lfloor\frac{n}{2^2}\rfloor]+2C}\\

&=T[{\lfloor\frac{n}{2^3}\rfloor]+3C}\\

\dots\\

&=T[{\lfloor\frac{n}{2^k}\rfloor]+kC}\\

\end{split}</script><p>设在第k次迭代的时候长度下降到2，  此时有$\frac{n}{2^k}=2$解出$k=\log_2n-1$，所以有$T[n]=(\log_2n-1)C=O(\log_2n)$，所以算法的时间复杂度为$O(logn)$</p>
<h3 id="leetcode154-有重复元素-1"><a href="#leetcode154-有重复元素-1" class="headerlink" title="leetcode154 有重复元素"></a>leetcode154 有重复元素</h3><p>最坏的情况，当出现$A[m]==A[p]$的情况的时候有递推表达式：</p>
<script type="math/tex; mode=display">
\begin{split}
T(n)&=2T[{\lfloor\frac{n}{2}\rfloor]+C}\\
&=2^2T[{\lfloor\frac{n}{2^2}\rfloor]+C+2C}\\
&=2^3T[{\lfloor\frac{n}{2^3}\rfloor]+C+2C+2C}\\
\dots\\
&=2^kT[{\lfloor\frac{n}{2^k}\rfloor]+(2k-1)C}\\
\end{split}</script><p>设当第k次的时候下降到n=1，因此有$\frac{n}{2^k}=1$推出$k=\log_2n$所以有$T(n)=n+(2\log_2n-1)C=O(n)$,所以时间复杂度为O(n)。如果没有出现$A[m]==A[p]$的情况则和无重复值的情况一样，时间复杂度为$O(n)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>使用迭代和循环两种方式实现。 循环的时候比较的选择？mid是该和左边还是右边比呢？我自己写的是和左边的比，但是我看leetcode的题解都是和右边的比。</p>
<h3 id="leetcode153-无重复元素-2"><a href="#leetcode153-无重复元素-2" class="headerlink" title="leetcode153 无重复元素"></a>leetcode153 无重复元素</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*leetcode#153</span></span><br><span class="line"><span class="comment">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span> || nums[<span class="number">0</span>]&lt;nums[len<span class="number">-1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];<span class="comment">//长度为1的时候或者不旋转的时候直接返回</span></span><br><span class="line">        <span class="comment">// return dc_find(nums, 0, len-1);</span></span><br><span class="line">        <span class="keyword">return</span> loop_find(nums, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dc_find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((hi -lo)==<span class="number">1</span>) <span class="keyword">return</span> nums[hi];</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = lo + (hi -lo)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(nums[mid]&gt;nums[lo]) ans = dc_find(nums, mid, hi);</span><br><span class="line">		<span class="keyword">else</span> ans = dc_find(nums, lo, mid);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loop_find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(lo&lt;hi)&#123;</span><br><span class="line">			<span class="keyword">if</span>((hi-lo)==<span class="number">1</span>) &#123;</span><br><span class="line">				ans = nums[hi];</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			mid = lo + (hi -lo)/<span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(nums[mid]&gt;nums[lo]) lo = mid ;</span><br><span class="line">			<span class="keyword">else</span> hi = mid ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* code */</span></span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">	Solution Sol;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Sol.findMin(vec)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="leetcode154-有重复元素-2"><a href="#leetcode154-有重复元素-2" class="headerlink" title="leetcode154 有重复元素"></a>leetcode154 有重复元素</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c++</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">leetcode#154</span></span><br><span class="line"><span class="comment">https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">1</span> || nums[<span class="number">0</span>]&lt;nums[len<span class="number">-1</span>]) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> dc_find(nums, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">dc_find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>((hi -lo)==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">min</span>(nums[lo], nums[hi]);<span class="comment">// 与无重复值的情况不同</span></span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> mid = lo + (hi -lo)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(nums[mid]&gt;nums[lo]) ans = dc_find(nums, mid, hi);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]==nums[lo])&#123;</span><br><span class="line">			ans = <span class="built_in">min</span>(dc_find(nums, lo, mid), dc_find(nums, mid, hi));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ans = dc_find(nums, lo, mid);</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/* code */</span></span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> ,<span class="number">2</span> &#125;;</span><br><span class="line">	Solution Sol;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;Sol.findMin(vec)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是：<code>if((hi -lo)==1) return min(nums[lo], nums[hi]);</code> 递归的退出条件， 与无重复值的情况不同是可能出现只有两个值的时候最小值在左边的情况，所以需要比较最小值，而不是直接返回第二个。比如$[2,3,2]$ 的情况，划分为两个子问题$[2, 3] 与[3,2]$第一个子问题的时候最小值在第一个元素。</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>最小值</tag>
        <tag>分治</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统</title>
    <url>/2019-11-19-%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F.html</url>
    <content><![CDATA[<h1 id="推荐系统"><a href="#推荐系统" class="headerlink" title="推荐系统"></a>推荐系统</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>推荐的基本思路是根据历史数据比如用户以往的喜好或者相似用户的喜好来预测用户未来的喜好。基本假设是：（1）用户的喜好是会保持的并且随着时间而缓慢改变。（2）拥有相同品味的用户对与一个项目的打分也是相似的。因此可以根据以往的历史数据来进行推荐。</p>
<p>与搜索的不同：搜索的数据不是根据用户的资料而定制的，给出的答案是与搜素查询语句相关联的结果。</p>
<a id="more"></a>
<h2 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h2><h3 id="基于内容的方法"><a href="#基于内容的方法" class="headerlink" title="基于内容的方法"></a>基于内容的方法</h3><p>基于内容的方法基于这样一个事实：一个用户的兴趣应该和被推荐物品的描述想匹配。核心思路是找到用户资料与物品之间的相似度，推荐相似度高的物品。</p>
<p>步骤为：</p>
<ul>
<li>描述将被推荐的物品I</li>
<li>建立用户个人资料U来描述用户喜欢的物品</li>
<li>比较物品和用户个人资料来决定推荐的物品</li>
</ul>
<p>用户个人资料与物品的描述可以根据关键词进行向量化。使用例如TF-IDF的方法将物品与个人资料向量话后，就可以计算两者的相似度了。</p>
<h4 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h4><p>使用预先相似度计算这两个向量的相似度。对与两个n维向量X和Y其余弦相似度为：</p>
<script type="math/tex; mode=display">
sim(X,Y)=\dfrac{X\cdot Y}{||X||\times ||Y||}</script><p>分子是点乘，$||X||=\sqrt {x_1^2+x_2^2+\dots+x_n^2}$ 是向量的欧几里得范数，也就是向量的长度。</p>
<h3 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h3><p>协同过滤Collaborative Filtering有两中假设</p>
<ul>
<li>基于用户的协同过滤：假设之前对各物品打分相似的用户对于一个新的物品的打分也是相似的</li>
<li>基于物品的协同过滤：假设两个物品的用户打分是相似的，那么一个新用户对二者的打分也是相似的。</li>
</ul>
<p>算法的步骤是：</p>
<ul>
<li>对所有的用户或物品根据他们与当前的用户或物品的相似度来进行赋权。</li>
<li>选择相邻的用户或者物品的一个自己作为推荐</li>
<li>对于一个用户对一个具体的物品的打分，使用相邻的用户对该物品（或者与该物品相似物品）的打分来预测。</li>
<li>推荐拥有最高预测打分值的物品。</li>
</ul>
<p>用户/物品之间的相似度可以用余弦相似度或者皮尔森相关系数。</p>
<p><a href="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/correlation_coefficient.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/correlation_coefficient.jpg" class="lazyload"></a></p>
<p>最终的打分的预测更新为：</p>
<p><a href="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/update_rating.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/update_rating.jpg" class="lazyload"></a></p>
<p>用户u对物品i的打分有原来的该用户的平均打分$\bar r_u$与和该用户最相似的用户一起决定。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_1.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_1.jpg" class="lazyload"></a></p>
<p>为了预测Jane对Aladdin的打分，第一步首先计算每个用户对电影的平均打分。第二步计算其他4个用户与Jane 的相似度，使用的是余弦相似度并且其他用户对Aladdin的打分不算进去，因此用的是除了Aladdin外的3部电影来计算的。计算出来选择与Jane最相似的2个用户Joe、Jorge。</p>
<p><a href="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_2.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/example_2.jpg" class="lazyload"></a></p>
<p>根据前面两部计算的结果计算Jane对Aladdin的打分。</p>
<h2 id="推荐系统的评测"><a href="#推荐系统的评测" class="headerlink" title="推荐系统的评测"></a>推荐系统的评测</h2><p>主要使用精确率，召回率，F1-Score3个指标来进行评价。</p>
<p><a href="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/presicion_recall.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/presicion_recall.jpg" class="lazyload"></a></p>
<p>F1-Score的计算方式为：</p>
<script type="math/tex; mode=display">
F1-Score = \dfrac{2Precison\times Recall}{Precision+Recall}</script><p>精确率表示所有相关的物品中被推荐出来的比例，召回率表示所有推荐的物品中实际相关的比例，F1-Score则是二者的总体评价。</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>国科大</tag>
        <tag>课程</tag>
        <tag>余弦相似度</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类方法</title>
    <url>/2019-11-19-%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="聚类方法"><a href="#聚类方法" class="headerlink" title="聚类方法"></a>聚类方法</h1><p>聚类属于无监督学习，因为输入的数据是没有标签的，通过算法每个样本自动的划分到相应的簇中。</p>
<h2 id="K-means"><a href="#K-means" class="headerlink" title="K-means"></a>K-means</h2><p>k均值是一种基于形心的技术。给定一个包含n 个数据对象的数据库，以及要生成的簇的数目k，一个划分类的算法将数据对象组织为k 个划分（k≤n），其中每个划分代表一个簇。通常会采用一个划分准则（经常称为相似度函数，similarity function），例如距离dist(i,j)，以便在同一个簇中的对象是“相似的”，而不同簇中的对象是“相异的”。</p>
<p>K-means把簇的形心定义为簇内点的均值，通过贪心的方法不断迭代形心的坐标，直到形心的坐标不再改变而结束迭代。</p>
<a id="more"></a>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>算法的步骤为：</p>
<ul>
<li>首先在数据集D中选择k个对象，每个对象代表一个簇的初试均值即形心。</li>
<li>对剩下的对象，根据其与这个k个形心的欧式距离将其分配到距离最近的形心的簇。</li>
<li>完成了分配后重新计算每个簇的均值中心点并更新。</li>
<li>使用更新后的均值中心点，重新分配每一个对象。</li>
<li>不断迭代，直到本轮的中心点与上一轮的相同，即本轮形成的簇与上一轮相同。</li>
</ul>
<h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p>伪代码为：</p>
<p><a href="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/kmeans_code.jpg" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://res.cloudinary.com/bravey/image/upload/v1574157674/blog/Data%20Mining/kmeans_code.jpg" class="lazyload"></a></p>
<p>K-means对离群点敏感，因为当一个离群点被分配到一个簇的时候，可能会严重扭曲簇的均值。</p>
<p>k中心点算法是基于对象的，通过挑选实际的对象来代表簇，其余的对象被分配与其最为相似的代表对象所在的簇。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《数据挖掘概念与技术》第3版 第十章聚类分析：基本概念和方法</p>
]]></content>
      <categories>
        <category>数据挖掘</category>
      </categories>
      <tags>
        <tag>聚类</tag>
        <tag>K-Means</tag>
        <tag>国科大</tag>
        <tag>课程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis源码阅读——SDS</title>
    <url>/Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94SDS/2019-03-22-Redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E2%80%94%E2%80%94SDS.html</url>
    <content><![CDATA[<h1 id="Redis源码阅读——SDS"><a href="#Redis源码阅读——SDS" class="headerlink" title="Redis源码阅读——SDS"></a>Redis源码阅读——SDS</h1><p>参考Redis设计与实现 以及网上博客阅读Redis源码。</p>
<a id="more"></a>
<p>SDS相关知识点见读书笔记。</p>
<h2 id="创建和销毁"><a href="#创建和销毁" class="headerlink" title="创建和销毁"></a>创建和销毁</h2><p>为了能够对sds进行相关API的测试，因此把sds模块单独提出来。阅读Redis的Makefile发现，编译sds模块需要的源文件包括<code>sds.c</code>, <code>sds.h</code> <code>zmalloc.c</code> </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test-sds: sds.c sds.h</span><br><span class="line">        $(REDIS_CC) sds.c zmalloc.c -DSDS_TEST_MAIN $(FINAL_LIBS) -o /tmp/sds_test</span><br><span class="line">        /tmp/sds_test</span><br></pre></td></tr></table></figure></div>
<p>但是实际编译后会发现会报很多函数未定义的错。原因是redis源码里面sds的内存分配、释放、重分配这些函数是封装成zmalloc,zfee这些函数的，只单纯的把zmalloc.c提取出来是远远不够的。后面发现redis的作者已经把sds给单独提出来了。包括三个源文件<code>sds.c</code>,<code>sds.h</code>,<code>sdsalloc.h</code> 因此执行如下操作即可单独把redis的sds模块提取出来。</p>
<h3 id="提取sds模块"><a href="#提取sds模块" class="headerlink" title="提取sds模块"></a>提取sds模块</h3><ol>
<li><p>新建redis_sds测试目录</p>
<p>选择合适的目录下新建</p>
<p><code>mkdir redis_sds</code></p>
</li>
<li><p>复制源文件至redis_sds目录下</p>
<p>在redis源码的src目录下执行：</p>
<p><code>cp sds.c ~/redis_sds/</code></p>
<p><code>cp sds.h ~/redis_sds/</code></p>
<p><code>cp sdsalloc.h ~/redis_sds/</code></p>
</li>
<li><p>修改sdsalloc.h </p>
<p>复制过来的sdsalloc.h 将sds模块的内存函数封装为使用zmalloc函数。为了简化处理直接使用libc的malloc函数来进行内存管理，同时将zmalloc.h给注释掉。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include "zmalloc.h"</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_malloc malloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_realloc realloc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> s_free free</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>新建主函数</p>
<p>新建主函数sds_test.c</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sds.c"</span></span></span><br><span class="line"><span class="comment">//#include "sds.h"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    sds s = sdsnew(<span class="string">"Hello World!"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Length:%d, Type:%d\n"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class="line"></span><br><span class="line">    s = sdscat(s, <span class="string">"The length of this sentence is greater than 32 bytes"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Length:%d, Type:%d\n"</span>, sdslen(s), sdsReqType(sdslen(s)));</span><br><span class="line"></span><br><span class="line">    sdsfree(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>直接include sds.c 即可，因为如果#include “sds.h” 的话，sdsReqType这个函数并没有在sds.h里面声明，而且因为sdsReqType的申明是：</p>
<p><code>static inline char sdsReqType(size_t string_size) {</code>  有static限制所以不能在sds.h中先声明，所以为了简单就直接#include 了sds.c了</p>
</li>
<li><p>编译  </p>
<p>为了方便重复编译，所以写了个简单的Makefile。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test : sds_test.c sds.h sds.c sdsalloc.h</span><br><span class="line">        gcc -o sdstest sds_test.c</span><br></pre></td></tr></table></figure></div>
<p>只需要编译sds_test.c 即可。因为sds_test.c 里面是直接#include sds.c 了所以再</p>
<p><code>gcc -o sdstest sds_test.c sds.c</code> 会将sds.c 里面的函数重复编译两次，造成Multiple definition 问题。</p>
<p>之后只需要执行make命令就可以生成可执行文件sdstest。</p>
<p>执行后输出为：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./sdstest </span><br><span class="line">Length:12, Type:0</span><br><span class="line">Length:64, Type:1</span><br></pre></td></tr></table></figure></div>
<h3 id="sds的创建"><a href="#sds的创建" class="headerlink" title="sds的创建"></a>sds的创建</h3><p>通过<code>sdsnew</code> 来创建了一个sds。sdsnew源码为：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create a new sds string starting from a null terminated C string. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用？条件判断符来简化if语句对NULL的判断，直接使用strlen来返回字符指针的长度。</span></span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init); </span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是字符数组和字符指针是有区别的：字符指针的数据是存放在进程的虚拟地址空间的程序代码和数据段，是只读的不能修改。字符数组存放的字符串数据是存放在用户栈的，是可以更改的。且字符指针的数据没有”\0”这个结束符。</p>
<p>参考博客讲的很好：<a href="https://blog.csdn.net/on_1y/article/details/13030439" target="_blank" rel="noopener">https://blog.csdn.net/on_1y/article/details/13030439</a></p>
<p><code>sdsnew</code> 通过把字符串长度和字符串传递给<code>sdsnewlen</code>，来完成创建。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Create a new sds string with the content specified by the 'init' pointer</span></span><br><span class="line"><span class="comment"> * and 'initlen'.</span></span><br><span class="line"><span class="comment"> * If NULL is used for 'init' the string is initialized with zero bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The string is always null-termined (all the sds strings are, always) so</span></span><br><span class="line"><span class="comment"> * even if you create an sds string with:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * mystring = n("abc",3);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You can print the string with printf() as there is an implicit \0 at the</span></span><br><span class="line"><span class="comment"> * end of the string. However the string is binary safe and can contain</span></span><br><span class="line"><span class="comment"> * \0 characters in the middle, as the length is stored in the sds header. */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);  <span class="comment">//返回字符串对应的type</span></span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    空字符串使用sdshdr8来存储，而不是sdshdr5,（虽然长度小于32），因为sdshdr5不适合扩容。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type); <span class="comment">// 返回对应类型的sdsheader长度。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 申请头部+字符串+NULL的大小。(单位为byte)</span></span><br><span class="line">    <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>); <span class="comment">// 将sh后面对应大小的字节全部置为0；</span></span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen; <span class="comment">//s指针指向字符串的首字节。</span></span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>; <span class="comment">// fp指针指向flag</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;  <span class="comment">// 初始化sdshdr</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);<span class="comment">// 设置flag这个字节的具体值</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s); <span class="comment">// 获取header指针sh</span></span><br><span class="line">            sh-&gt;len = initlen; <span class="comment">//header中len的初始</span></span><br><span class="line">            sh-&gt;alloc = initlen; <span class="comment">//header 中alloc的初试</span></span><br><span class="line">            *fp = type;  <span class="comment">//flag 的初始。</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">16</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type; </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">32</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen); <span class="comment">// 将字符串拷贝到s(也就是buf数组)</span></span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>; <span class="comment">//在字符串后面添加终止符</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>char type = sdsReqType(initlen);</code> 获取sds类型，源码分析在读书笔记里面有记录。源码为</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>) <span class="comment">// string_size &lt; 2^5</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)  <span class="comment">//string_size &lt; 2^8</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)	<span class="comment">//string_size &lt; 2^16</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1l</span>l&lt;&lt;<span class="number">32</span>)  <span class="comment">//string_size &lt; 2^32</span></span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>采用左移来计算对应多少位的范围，而不是用2^5 这样的乘法。<strong>直接移位比使用幂来计算快很多</strong>。</p>
<p><code>1&lt;&lt;5</code>   计算出来就是2^5 次方。1是int型，4byte32位。最低8bit位的二进制为：00000001 左移5位后变成了：00100000 对应的十进制既是32。</p>
<p>计算n个bit位的最大值：(1&lt;&lt;n) -1</p>
<p>但是需要注意位数不够的情况。因为1是int型，只有32个bit。所以在左移32个bit时，需要使用long long int型。用1ll来表示，此时1ll为64个bit。</p>
<p>还得考虑机器是否为64位机器，在32位机器上LONG_MAX = 2147483647L，64位机器上LONG_MAX = 9223372036854775807L 。不论32位机器还是64位机器上 LLONG_MAX 都是9223372036854775807L 。所以当LONG_MAX == LLONG_MAX 说明字长为64bit。加上条件编译，说明在32位机器上不使用sdshdr32而直接跳到了sdshdr64，仅仅在64位机器上使用sdshdr32。原因是什么？还没想通</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sdsHdrSize</span><span class="params">(<span class="keyword">char</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr5);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr8);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr16);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr32);</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr64);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因为struct里面的buf数组是柔性数组，计算结构体的大小的时候不会计算在内。</p>
<p><code>memset(sh, 0, hdrlen+initlen+1);</code>  memset函数会将sh中当前位置后面的<code>hdrlen+initlen+1</code>个字节全部置于0。 注意sh指向的是<code>hdrlen+initlen+1</code> 个字节的首个字节。（sh指针存储的地址就是首个字节的地址。） </p>
<p>memset源码为：<a href="https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c" target="_blank" rel="noopener">https://github.com/gcc-mirror/gcc/blob/master/libgcc/memset.c</a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Public domain.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *</span><br><span class="line"><span class="built_in">memset</span> (<span class="keyword">void</span> *dest, <span class="keyword">int</span> val, <span class="keyword">size_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptr = dest; <span class="comment">// 用char来限定每次指针+1只移动一个字节。</span></span><br><span class="line">  <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>)</span><br><span class="line">    *ptr++ = val;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>假设<code>hdrlen+initlen+1</code> 为8 ，经过memset后，从sh首字节开始共有8个字节都被置为0。</p>
<p><a href="https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/memset.png" class="lazyload"></a></p>
<p>指针的类型时用来确定指针需要从首地址寻址（偏移）多少个字节。比如int * 指针说明指针存储的地址朝后面偏移3个字节才是这个int类型的所有数据。即指针存储的地址时起点，而终点是由类型来确定的。此外，类型也是指针加减的步长，比如char类型的步长就是1byte，而uint_16类型的指针步长就是2byte。</p>
<p>随后用switch语句对不同类型的sdshdr设置初始值。</p>
<p>首先是sdshdr5</p>
<p> <code>*fp = type | (initlen &lt;&lt; SDS_TYPE_BITS)</code> 使用移位和或操作的方式来对8个bit位赋值。(不得不感慨这些操作真的是太巧妙了)</p>
<p>假设initlen为3。则initlen的二进制为0000 0011（应该是8byte（64位机器）或者4byte（32位机器），为了简单用1byte的二进制表示）而SDS_TYPE_BITS 为3。所以先将initlen 左移3个bit 变成0000 0001 1000(共有8byte或者4byte)。再与type进行或运算。type为0000 0000 进行或运算后，得到的内容是8bit的，因为type是char类型，即0001 1000 。</p>
<p>其他sdshdr类型的设置都差不多，详解下sdshdr8.</p>
<p><code>SDS_HDR_VAR(8,s)</code>  <code>SDS_HDR_VAR</code> 是个宏定义的函数</p>
<p><code>#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</code></p>
<p>采用宏定义函数的好处是</p>
<ol>
<li>能够减少额外的开销 因为如果写成普通函数的话，函数的调用会在用户栈开辟空间，形参压栈，返回时还需要释放栈，可想而知的开销。使用宏定义函数则在代码规模和速度方面都比函数更胜一筹。宏定义的本质就是替换，所以在使用宏定义函数的地方，执行的时候相当于是在直接执行<code>struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)))</code> 这句代码</li>
<li>函数的参数必须被声明为一种特定的类型，所以它只能在类型合适的表达式上使用。而宏定义则可以用于整形、长整形、单浮点型、双浮点型以及其他任何可以用“&gt;”操作符比较值大小的类型，也就是说，宏是与类型无关的。（有点C++模版类的感觉）</li>
</ol>
<p>宏定义函数中的## 是（token-pasting）<strong>符号连接操作符</strong> 直接将形参T链接到sdshdr上面。也就是sdshdrT。</p>
<p>所以这句代码也就很简单了，将字符串指针s向后移动header的大小，也就得到了header的指针。（不过有个疑问是为什么还要重新获取headr的地址，最开始不就是指向了header吗？，难道memset是直接对sh进行操作的？测试过了，memset不会修改sh的地址，所以应该是为了再次确保sh一定指向header）</p>
<p>解释一下：SDS_HDR_VAR 的作用是将sh的类型修改为结构体指针，因为之前sh 一直都是空指针，(虽然指针的指向地址是headr，但是没有限定它类型)不然后面没法用sh-&gt;len, sh-&gt;alloc 来访问对应的结构体成员。</p>
<p>最开始创建的时候alloc 和len是一样大的，没有分配多余空间）</p>
<p><code>memcpy(s, init, initlen);</code> 函数将init的前initlen个字符拷贝给s。</p>
<p>memcpy源码为：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Public domain.  */</span><br><span class="line">#include &lt;stddef.h&gt;</span><br><span class="line"></span><br><span class="line">void *</span><br><span class="line">memcpy (void *dest, const void *src, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">  char *d = dest;</span><br><span class="line">  const char *s = src;</span><br><span class="line">  while (len--)</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  return dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>整个过程中的三个指针sh,s,fp对应关系如下图</p>
<p><a href="https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://res.cloudinary.com/bravey/image/upload/v1553525055/blog/sds.png" class="lazyload"></a></p>
</li>
</ol>
<h2 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h2><p>销毁使用sdsfree来实现</p>
<p>源码为：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Free an sds string. No operation is performed if 's' is NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    s_free((<span class="keyword">char</span>*)s-sdsHdrSize(s[<span class="number">-1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>s[-1],就是指针s向后移动移位，也就是flag的位置。将s移动到sh的位置，释放sh指针也就释放了整个sds内存。</p>
<p>疑惑：sh指针在sdsnewlen函数中是个局部变量，在sdsnewlen函数中是自动释放的，这里并没有传递sh指针为什么也可以释放对应的空间？</p>
<p>自己想了下：malloc 函数传递的参数是需要分配的内存大小(len)，返回的是指针也就是地址。free()函数只用将malloc函数返回的指针(地址)作为参数传入，就可以释放之前该地址分配到的内存空间。而地址只是首地址，总共的偏移量（大小），应该是由操作系统在内存分配的时候就记录了的。</p>
<p>博客中记录：申请的时候实际上占用的内存要比申请的大。因为超出的空间是用来记录对这块内存的管理信息。额外的空间用来记录管理信息——分配块的长度，指向下一个分配块的指针等等。果然malloc的时候用来一个struct来记录分配的信息。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_control_block</span> &#123;</span> </span><br><span class="line">  <span class="keyword">int</span> is_available;    <span class="comment">//一般来说应该是一个可用空间的首地址，但这里英文单词却显示出空间是否可用的一个标记</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">size</span>;            <span class="comment">//这是实际空间的大小 </span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></div>
<p><a href="http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html" target="_blank" rel="noopener">http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html</a></p>
<p>free()就是根据这个结构体的信息来释放malloc()申请的空间</p>
<p>另外的疑惑：释放完空间后，s 指针不用把它指向null吗？  </p>
<p>暂时就只是创建和销毁的源码把，看了两天，阅读源码真的是酣畅淋漓，收获良多。学到了很多奇妙的C技巧，还对操作系统的知识有了更具象的理解。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>阅读sdsfromlonglong部分的源码：</p>
<p>sdsfromlonglong 函数用于将一个long long 类型的整形数字转换为字符数组。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create an sds string from a long long value. It is much faster than:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sdscatprintf(sdsempty(),"%lld\n", value);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">sdsfromlonglong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];  <span class="comment">// 给buf数组分配最小的空间，21的长度</span></span><br><span class="line">    <span class="keyword">int</span> len = sdsll2str(buf,value); <span class="comment">//将long long 转为字符数组存储在buf中，并返回字符串的长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(buf,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>可以看到主要的转换操作在sdsll2str这个函数中：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Helper for sdscatlonglong() doing the actual number -&gt; string</span></span><br><span class="line"><span class="comment"> * conversion. 's' must point to a string with room for at least</span></span><br><span class="line"><span class="comment"> * SDS_LLSTR_SIZE bytes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the length of the null-terminated string</span></span><br><span class="line"><span class="comment"> * representation stored at 's'. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_LLSTR_SIZE 21</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsll2str</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p, aux;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> v; </span><br><span class="line">    <span class="keyword">size_t</span> l;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generate the string representation, this method produces</span></span><br><span class="line"><span class="comment">     * an reversed string. */</span></span><br><span class="line">    v = (value &lt; <span class="number">0</span>) ? -value : value;  <span class="comment">//判断是否为负数</span></span><br><span class="line">    p = s;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        *p++ = <span class="string">'0'</span>+(v%<span class="number">10</span>); <span class="comment">// 除以10取余数</span></span><br><span class="line">        v /= <span class="number">10</span>;     <span class="comment">//去除个位</span></span><br><span class="line">    &#125; <span class="keyword">while</span>(v);</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) *p++ = <span class="string">'-'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute length and add null term. */</span></span><br><span class="line">    l = p-s;   <span class="comment">// 计算出字符串的长度 不含终止符</span></span><br><span class="line">    *p = <span class="string">'\0'</span>; <span class="comment">// 首地址填终止符。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Reverse the string. */</span></span><br><span class="line">    p--;</span><br><span class="line">    <span class="keyword">while</span>(s &lt; p) &#123;</span><br><span class="line">        aux = *s;</span><br><span class="line">        *s = *p;</span><br><span class="line">        *p = aux;</span><br><span class="line">        s++;</span><br><span class="line">        p--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    *p++ = <span class="string">'0'</span>+(v%<span class="number">10</span>); <span class="comment">// 除以10取余数</span></span><br><span class="line">    v /= <span class="number">10</span>;     <span class="comment">//去除个位</span></span><br><span class="line">&#125; <span class="keyword">while</span>(v);</span><br></pre></td></tr></table></figure></div>
<p>假设v是352，变成字符串是将每一个对应的10进制上面的3,5,2这三个个位、十位、百位的数字给单独变成字符。</p>
<p><code>*p++ = &#39;0&#39;+(v%10);</code> p 指针是字符数组buf的首地址，而将整型变成字符型的操作就是与字符’0’ 相加，这样就可以对应的数字变成字符类型。同时p相应的加1来指向下一个byte用来存储下一个被转换的char。</p>
<p>char类型存储的是对应字符的ascii值，ASCII表为：<a href="https://baike.baidu.com/item/ASCII/309296" target="_blank" rel="noopener">https://baike.baidu.com/item/ASCII/309296</a> ，所以字符的运算实际上是对应的ASCII的值的运算。<br>v%10是除以10取余数，352%10 =2； 35%10=5，所以也就是取得v值的10进制上面的个位数。<br>所以在while循环里面每次对v除以10并取余，就可以得到对应long long 型的字符串。<br>但是因为每次得到的字符都是最后面的个位数，所以352，所输出的字符串数组为：‘2’， ‘3’， ‘5’ 是一个倒序的，因此还需要再反转一次。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reverse the string. */</span> </span><br><span class="line">p--;</span><br><span class="line"><span class="keyword">while</span>(s &lt; p) &#123;</span><br><span class="line">    aux = *s;</span><br><span class="line">    *s = *p;</span><br><span class="line">    *p = aux;</span><br><span class="line">    s++;</span><br><span class="line">    p--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>字符串反转，首尾各有一个指针，当首指针小于尾指针的时候，交换数字，并同时向中间移动</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/yangbodong22011/article/details/78419966" target="_blank" rel="noopener">https://blog.csdn.net/yangbodong22011/article/details/78419966</a></p>
]]></content>
      <categories>
        <category>源码阅读</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>ping 无法连接外网</title>
    <url>/ping%20%E9%97%AE%E9%A2%98.html</url>
    <content><![CDATA[<h2 id="ping-无法连接外网"><a href="#ping-无法连接外网" class="headerlink" title="ping 无法连接外网"></a>ping 无法连接外网</h2><a id="more"></a>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>ping外网ping不通</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yky@hw076:~/tmux&gt; ping www.baidu.com</span><br><span class="line">ping: unknown host www.baidu.com</span><br><span class="line">yky@hw076:~/tmux&gt; ping 8.8.8.8</span><br><span class="line">connect: Network is unreachable</span><br></pre></td></tr></table></figure></div>
<p>ping内网可以ping通</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hw076:~ # ping 172.18.11.114</span><br><span class="line">PING 172.18.11.114 (172.18.11.114) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.18.11.114: icmp_seq=1 ttl=64 time=0.193 ms</span><br><span class="line">64 bytes from 172.18.11.114: icmp_seq=2 ttl=64 time=0.216 ms</span><br><span class="line">64 bytes from 172.18.11.114: icmp_seq=3 ttl=64 time=0.207 ms</span><br><span class="line">64 bytes from 172.18.11.114: icmp_seq=4 ttl=64 time=0.200 ms</span><br><span class="line">^C</span><br><span class="line">--- 172.18.11.114 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 2999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.193/0.204/0.216/0.008 ms</span><br></pre></td></tr></table></figure></div>
<p>ifconfig信息为：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hw076:~ # ifconfig </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 90:E2:BA:15:C9:C4  </span><br><span class="line">          inet addr:172.18.11.76  Bcast:192.168.1.255  Mask:255.255.0.0</span><br><span class="line">          inet6 addr: fe80::92e2:baff:fe15:c9c4/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:9725797 errors:0 dropped:506 overruns:0 frame:0</span><br><span class="line">          TX packets:21023 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:598731249 (570.9 Mb)  TX bytes:2767270 (2.6 Mb)</span><br><span class="line">          Memory:fb480000-fb500000 </span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:276 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:276 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:25088 (24.5 Kb)  TX bytes:25088 (24.5 Kb)</span><br></pre></td></tr></table></figure></div>
<p>route显示路由信息如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hw076:/etc/netconfig.d # route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         *               0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class="line">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class="line">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure></div>
<p>原因是route没有配置网关，gateway是空着的。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过查看其他可以正常访问的节点的路由信息，得知网关节点为：172.18.0.254。因此增加默认网关节点配置。</p>
<p>执行命令：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route add default  gw 172.18.0.254</span><br></pre></td></tr></table></figure></div>
<p>再次查看路由信息：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hw076:~ # route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         172.18.0.254    0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">loopback        *               255.0.0.0       U     0      0        0 lo</span><br><span class="line">link-local      *               255.255.0.0     U     0      0        0 eth0</span><br><span class="line">172.18.0.0      *               255.255.0.0     U     0      0        0 eth0</span><br></pre></td></tr></table></figure></div>
<p>再次ping8.8.8.8显示正常，问题解决。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>运维</tag>
        <tag>网络问题</tag>
      </tags>
  </entry>
  <entry>
    <title>shell 脚本遍历redis数据库</title>
    <url>/%E4%BD%BF%E7%94%A8shell%E8%84%9A%E6%9C%AC%E9%81%8D%E5%8E%86redis%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89kv%E5%AF%B9.html</url>
    <content><![CDATA[<h2 id="使用shell脚本遍历redis数据库中的所有kv对"><a href="#使用shell脚本遍历redis数据库中的所有kv对" class="headerlink" title="使用shell脚本遍历redis数据库中的所有kv对"></a>使用shell脚本遍历redis数据库中的所有kv对</h2><p>记录下如何使用shell通过redis-cli 命令来操作redis数据库，因为直接在命令行中输入</p>
<p><code>redis-cli command</code> 的话command必须是单个单词，不能像是<code>KEYS *</code> 这种.</p>
<a id="more"></a>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">filename=&apos;redis&apos;`date +%Y-%m-%d_%H:%M`</span><br><span class="line">work_path=$(dirname &quot;$0&quot;) </span><br><span class="line">echo &quot;实例化redis数据文件为:$work_path/$filename&quot;</span><br><span class="line">echo &quot;keys *&quot; | redis-cli &gt; key_db.txt</span><br><span class="line">echo &quot;将所有key保存到:$work_path/key_db.txt&quot;</span><br><span class="line">for line in `cat key_db.txt`</span><br><span class="line">do</span><br><span class="line">        echo &quot;key:$line &quot; &gt;&gt;$work_path/$filename.txt</span><br><span class="line">        echo &quot;key-value:&quot; &gt;&gt;$work_path/$filename.txt</span><br><span class="line">        echo &quot;hgetall $line&quot; | redis-cli &gt;&gt;$work_path/$filename.txt</span><br><span class="line">done</span><br></pre></td></tr></table></figure></div>
<p>使用echo 来把命令输出到管道然后再传递给redis-cli。在循环里面也是使用echo来把字符串输入到文件中。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用YCSB 评测redis性能</title>
    <url>/%E4%BD%BF%E7%94%A8YCSB%20%E8%AF%84%E6%B5%8Bredis%E6%80%A7%E8%83%BD.html</url>
    <content><![CDATA[<h1 id="使用YCSB-评测redis性能"><a href="#使用YCSB-评测redis性能" class="headerlink" title="使用YCSB 评测redis性能"></a>使用YCSB 评测redis性能</h1><p>YCSB是雅虎推出的可以评测许多主流数据库性能的基准测试，其中包括Redis。</p>
<a id="more"></a>
<h2 id="安装YCSB"><a href="#安装YCSB" class="headerlink" title="安装YCSB"></a>安装YCSB</h2><ol>
<li><p>安装java和maven</p>
<ol>
<li><p>机子已经有了java，所以只用安装maven Ubuntu安装命令为：</p>
<p><code>sudo apt-get install maven</code></p>
</li>
</ol>
</li>
<li><p>安装YCSB </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone http://github.com/brianfrankcooper/YCSB.git</span><br><span class="line">cd YCSB</span><br><span class="line">mvn -pl com.yahoo.ycsb:redis-binding -am clean package</span><br></pre></td></tr></table></figure></div>
<p>必须是gitclone的源码包才能执行mvn 命令。wget或者curl下来包是已经编译好了的无需执行mvn命令。</p>
</li>
<li><p><code>mvn -pl com.yahoo.ycsb:redis-binding -am clean package</code> 报错：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[INFO] Scanning for projects...</span><br><span class="line">[ERROR] [ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding @ </span><br><span class="line">[ERROR] Could not find the selected project in the reactor: com.yahoo.ycsb:redis-binding -&gt; [Help 1]</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.</span><br><span class="line">[ERROR] Re-run Maven using the -X switch to enable full debug logging.</span><br><span class="line">[ERROR] </span><br><span class="line">[ERROR] For more information about the errors and possible solutions, please read the following articles:</span><br><span class="line">[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MavenExecutionException</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>原因：此命令是在gitclone后未编译的时候使用的。而我之前是下载的编译好的tar.gz包，解压后是已经编译好了的。所以再次执行编译的命令时会报错。</p>
<h2 id="使用YCSB"><a href="#使用YCSB" class="headerlink" title="使用YCSB"></a>使用YCSB</h2><p>将redis-server启动后开始使用YCSB</p>
<h3 id="设置数据库"><a href="#设置数据库" class="headerlink" title="设置数据库"></a>设置数据库</h3><p>需要先创建<code>usertable</code>的表，因为YCSB客户端默认是对<code>usertable</code> 进行操作。Redis将数据存储在内存中，不需要相关操作。</p>
<h3 id="选择合适的DB-interface"><a href="#选择合适的DB-interface" class="headerlink" title="选择合适的DB interface"></a>选择合适的DB interface</h3><p>YCSB的操作是通过DB interface来实现的。最基本的DB interface是<code>com.yahoo.ycsb.BasicDB</code>，会将输出输出到<code>System.out</code>里。可以通过继承DB interface来自定义DB interface，也可以使用原有的DB interface。Redis不需要此步操作。</p>
<h3 id="选择合适的负载"><a href="#选择合适的负载" class="headerlink" title="选择合适的负载"></a>选择合适的负载</h3><p>YCSB提供了6种负载，负载在worloads目录下。详情见<a href="https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads" target="_blank" rel="noopener">https://github.com/brianfrankcooper/YCSB/wiki/Core-Workloads</a></p>
<ol>
<li><strong>Workload A: Update heavy workload</strong> 读写比例为： 50/50 混合负载 </li>
<li><strong>Workload A: Update heavy workload</strong> 读写比例为：95/5  读为主的负载</li>
<li><strong>Workload C: Read only</strong>  100% 的读  只读负载</li>
<li><strong>Workload D: Read latest workload</strong>  读取最近的数据负载</li>
<li><strong>Workload E: Short ranges</strong>  小范围的查询负载</li>
<li><strong>Workload F: Read-modify-write</strong> 读修改写负载</li>
</ol>
<p>自定义负载：参考<a href="https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads" target="_blank" rel="noopener">https://github.com/brianfrankcooper/YCSB/wiki/Implementing-New-Workloads</a></p>
<p>可以通过修改参数文件或者新建java类来实现</p>
<p>需要注意的是YCSB的读写负载是针对哈希类型的数据而不是简单的字符串</p>
<h3 id="指定需要的运行参数"><a href="#指定需要的运行参数" class="headerlink" title="指定需要的运行参数"></a>指定需要的运行参数</h3><p>主要是指定redis的ip ，端口，密码等。</p>
<p>命令如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/ycsb load redis -s -P workloads/workloada -p &quot;redis.host=127.0.0.1&quot; -p &quot;redis.port=6379&quot; &gt; outputLoad.txt</span><br></pre></td></tr></table></figure></div>
<p><code>-s</code> : <strong>status</strong>.十秒打印一次状态</p>
<h3 id="加载负载"><a href="#加载负载" class="headerlink" title="加载负载"></a>加载负载</h3><p>命令如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/ycsb load redis -s -P workloads/workloada &gt; outputLoad.txt</span><br></pre></td></tr></table></figure></div>
<h3 id="运行负载"><a href="#运行负载" class="headerlink" title="运行负载"></a>运行负载</h3><p>命令如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./bin/ycsb run redis -s -P workloads/workloada &gt; outputRun.txt</span><br></pre></td></tr></table></figure></div>
<p>可以使用basic数据库来打印YCSB向数据库中写入的具体数据</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin/ycsb.sh load basic -P workloads/workloada</span><br><span class="line">bin/ycsb.sh run basic -P workloads/workloada</span><br></pre></td></tr></table></figure></div>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">https://datawine.github.io/2018/12/11/YCSB%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</a></p>
<p><a href="https://github.com/brianfrankcooper/YCSB/tree/master/redis" target="_blank" rel="noopener">https://github.com/brianfrankcooper/YCSB/tree/master/redis</a>  </p>
]]></content>
      <tags>
        <tag>redis</tag>
        <tag>benchmark</tag>
      </tags>
  </entry>
  <entry>
    <title>apt-get install失败</title>
    <url>/apt-get%20install%20%E5%A4%B1%E8%B4%A5.html</url>
    <content><![CDATA[<h2 id="apt-get-install失败"><a href="#apt-get-install失败" class="headerlink" title="apt-get install失败"></a>apt-get install失败</h2><a id="more"></a>
<h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ol>
<li><p>使用perf 报错 内核无法找到perf</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@hw103:/home/yky/redis-5.0.3# perf </span><br><span class="line">WARNING: perf not found for kernel 4.15.0-45</span><br><span class="line"></span><br><span class="line">  You may need to install the following packages for this specific kernel:</span><br><span class="line">    linux-tools-4.15.0-45-generic</span><br><span class="line">    linux-cloud-tools-4.15.0-45-generic</span><br><span class="line"></span><br><span class="line">  You may also want to install one of the following packages to keep up to date:</span><br><span class="line">    linux-tools-generic</span><br><span class="line">    linux-cloud-tools-generic</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<ol>
<li><p>安装此内核的通用工具时错误</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@hw103:/home/yky/redis-5.0.3# apt-get install  linux-tools-4.15.0-45-generic</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree       </span><br><span class="line">Reading state information... Done</span><br><span class="line">You might want to run &apos;apt-get -f install&apos; to correct these:</span><br><span class="line">The following packages have unmet dependencies:</span><br><span class="line"> console-setup : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class="line"> console-setup-linux : Depends: keyboard-configuration (= 1.178ubuntu2.7) but 1.108ubuntu15.3 is to be installed</span><br><span class="line">                       Breaks: keyboard-configuration (&lt; 1.138) but 1.108ubuntu15.3 is to be installed</span><br><span class="line"> linux-tools-4.15.0-45-generic : Depends: linux-tools-4.15.0-45 but it is not going to be installed</span><br><span class="line">E: Unmet dependencies. Try &apos;apt-get -f install&apos; with no packages (or specify a solution).</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用apt-get -f install 时报错</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: error processing archive /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb (--unpack):</span><br><span class="line"> subprocess new pre-installation script returned error exit status 1</span><br><span class="line">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class="line">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class="line">dpkg-query: warning: files list file for package &apos;keyboard-configuration&apos; missing; assuming package has no files currently installed</span><br><span class="line">Errors were encountered while processing:</span><br><span class="line"> /var/cache/apt/archives/keyboard-configuration_1.178ubuntu2.7_all.deb</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure></div>
<p>问题综述：</p>
<ol>
<li><code>apt-get install lib</code>时报错 Unmet dependencies</li>
<li><code>apt-get install -f</code> 时报错Sub-process /usr/bin/dpkg returned an error code (1)</li>
</ol>
</li>
</ol>
<ol>
<li><p>第一阶段解决办法</p>
<p>在/var/lib/dpkg/目录下有个info文件 ，然后文件中没有keyboard-configuration的相关文件但是有info的备份info_backup  ，这里面有相关的文件，于是将keyboard-configuration的所有相关文件都拷贝到了/var/lib/dpkg/info 中。</p>
<p>在info_backup目录下执行如下命令拷贝</p>
<p><code>cp keyboard-configuration.* ../info</code></p>
<p>随后再次执行安装内核通用工具 报错为第二阶段</p>
</li>
</ol>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ol>
<li><p>安装此内核的通用工具时时报错：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insserv: Starting redis depends on plymouth and therefore on system facility `$all&apos; which can not be true!</span><br><span class="line">insserv: exiting now without changing boot order!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: error processing package avahi-daemon (--configure):</span><br><span class="line"> subprocess installed post-installation script returned error exit status 1</span><br><span class="line">No apport report written because MaxReports is reached already</span><br><span class="line">                                                              No apport report written because MaxReports is reached already</span><br><span class="line">                                                                                                                            dpkg: dependency problems prevent configuration o</span><br><span class="line">f avahi-utils: avahi-utils depends on avahi-daemon; however:</span><br><span class="line">  Package avahi-daemon is not configured yet.</span><br><span class="line"></span><br><span class="line">dpkg: error processing package avahi-utils (--configure):</span><br><span class="line"> dependency problems - leaving unconfigured</span><br><span class="line">Setting up unattended-upgrades (1.1ubuntu1.18.04.9) ...</span><br><span class="line">dpkg: error processing package unattended-upgrades (--configure):</span><br><span class="line"> subprocess installed post-installation script returned error exit status 10</span><br><span class="line">No apport report written because MaxReports is reached already</span><br><span class="line">                                                              Setting up linux-tools-4.15.0-45 (4.15.0-45.48) ...</span><br><span class="line">Setting up linux-tools-4.15.0-45-generic (4.15.0-45.48) ...</span><br><span class="line">Processing triggers for initramfs-tools (0.122ubuntu8.14) ...</span><br><span class="line">Errors were encountered while processing:</span><br><span class="line"> udev</span><br><span class="line"> snapd</span><br><span class="line"> ubuntu-core-launcher</span><br><span class="line"> kmod</span><br><span class="line"> ubuntu-drivers-common</span><br><span class="line"> whoopsie</span><br><span class="line"> openssh-server</span><br><span class="line"> ssh</span><br><span class="line"> avahi-daemon</span><br><span class="line"> avahi-utils</span><br><span class="line"> unattended-upgrades</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>解决办法：/var/lib/dpkg/info 目录下将上述出现问题的模块的postinst文件重命名。</p>
<p>在/var/lib/dpkg/info 下写了个脚本</p>
<p>solution.sh</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">for pack in $(cat module.txt)</span><br><span class="line">do </span><br><span class="line">    mv &quot;$pack&quot;.postinst &quot;$pack&quot;.postinst.bak</span><br><span class="line">done</span><br></pre></td></tr></table></figure></div>
<p>其中module.txt的内容为</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">udev</span><br><span class="line">snapd</span><br><span class="line">ubuntu-core-launcher</span><br><span class="line">kmod</span><br><span class="line">ubuntu-drivers-common</span><br><span class="line">whoopsie</span><br><span class="line">openssh-server</span><br><span class="line">ssh</span><br><span class="line">avahi-daemon</span><br><span class="line">avahi-utils</span><br><span class="line">unattended-upgrades</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>执行脚本后 使用<code>sudo apt-get upgrade</code> 进行更新</p>
</li>
<li><p>参考：</p>
<ol>
<li><a href="https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/" target="_blank" rel="noopener">https://www.codelast.com/%E5%8E%9F%E5%88%9B-%E8%A7%A3%E5%86%B3ubuntu-%E6%97%A0%E6%B3%95%E7%94%A8-apt-get-install-%E5%AE%89%E8%A3%85%E4%BB%BB%E4%BD%95%E8%BD%AF%E4%BB%B6dpkg-error-processing-package-xxx%E7%9A%84%E9%97%AE/</a></li>
<li><a href="https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing" target="_blank" rel="noopener">https://askubuntu.com/questions/949760/dpkg-warning-files-list-file-for-package-missing</a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Make学习</title>
    <url>/make%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="make学习"><a href="#make学习" class="headerlink" title="make学习"></a>make学习</h1><p>开始阅读redis源码，都说redis很简单，源码不多。但是源码包下载下来后却发现不知道从何处入手，有那么多文件和源码。后面查找资料才发现阅读源码的第一步就是阅读Makefile，项目如何构建和源码间的关联都写在了Makefile文件中。之前没有接触过Makefile，记录下Make的学习。</p>
<a id="more"></a>
<h2 id="makefile的格式"><a href="#makefile的格式" class="headerlink" title="makefile的格式"></a>makefile的格式</h2><ol>
<li><p>概述</p>
<p>makefile 文件由一系列rules组成 rules的格式为：</p>
</li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure></div>
<p>​    “目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。 </p>
<p>​    每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。 </p>
<ol>
<li><p>target</p>
<p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。（make的时候指定文件名从而对该文件进行构建build）</p>
<p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。伪目标不生成文件，只执行命令。</p>
<p>比如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">      rm *.o</span><br></pre></td></tr></table></figure></div>
<p>此时执行<code>make clean</code> 命令则会进行<code>rm *.o</code> 的操作。</p>
<p>但是当存在clean这个文件时，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p>
<p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">clean:</span><br><span class="line">        rm *.o temp</span><br></pre></td></tr></table></figure></div>
<p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。 </p>
</li>
<li><p>prerequisites</p>
<p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。 </p>
<p>没有前置条件，就意味着它跟其他文件都无关，只要这个target文件还不存在 就需要执行命令构建</p>
<p>如果需要生成多个文件，往往采用下面的写法。 </p>
<p><code>source: file1 file2 file3</code>  </p>
<p>无需加上命令，当三个文件不存在时，执行<code>make source</code>就会生成这三个文件。</p>
</li>
<li><p>commands</p>
<p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。 </p>
<p>每行命令之前必须有一个tab键 </p>
<p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var-lost:</span><br><span class="line">    export foo=bar</span><br><span class="line">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure></div>
<p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。 </p>
<p>解决办法：</p>
<ol>
<li><p>命令写在同1行</p>
</li>
<li><p>换行符前加反斜杠转义</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var-kept:</span><br><span class="line">    export foo=bar; \</span><br><span class="line">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure></div>
<ol>
<li>加上<code>.ONESHELL:</code>命令 </li>
</ol>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.ONESHELL:</span><br><span class="line">var-kept:</span><br><span class="line">    export foo=bar; </span><br><span class="line">    echo &quot;foo=[$$foo]&quot;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
</li>
</ol>
<h2 id="makefile的语法"><a href="#makefile的语法" class="headerlink" title="makefile的语法"></a>makefile的语法</h2><ol>
<li><p>注释</p>
<p>井号（#）在Makefile中表示注释。 </p>
</li>
<li><p>回声（echoing）</p>
<p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p>
<p>在命令的前面加上@，就可以关闭回声。 </p>
<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>
</li>
<li><p>通配符</p>
<p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。 </p>
</li>
<li><p>模式匹配</p>
<p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br></pre></td></tr></table></figure></div>
<p>等同于</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1.o: f1.c</span><br><span class="line">f2.o: f2.c</span><br></pre></td></tr></table></figure></div>
<p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。 </p>
</li>
<li><p>变量和赋值符</p>
<p>Makefile 允许使用等号自定义变量。 </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt = Hello World</span><br><span class="line">test:</span><br><span class="line">    @echo $(txt)</span><br></pre></td></tr></table></figure></div>
<p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中 </p>
<p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。 </p>
</li>
<li><p>内置变量</p>
<p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性 gmake、cmake、dmake等等。</p>
<p>$(AR) ：函数库打包程序,将对应的gcc编译出来的obj文件打包成静态链接库程序。</p>
<p>ar可以集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。</p>
</li>
<li><p>自动变量</p>
<ol>
<li><p>$@指代当前目标，就是Make命令当前构建的那个目标  target</p>
</li>
<li><p>$&lt;指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1 </p>
</li>
<li><p>$？指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。 </p>
</li>
<li><p>$^指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。 </p>
</li>
<li><p>$<em>指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$</em> 就表示 f1。 </p>
</li>
<li><p>$(@D) 和 $(@F)$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src/input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。 </p>
</li>
<li><p>$(&lt;D) 和 $(&lt;F)</p>
<p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p>
</li>
</ol>
</li>
<li><p>其他</p>
<ol>
<li><p><code>.DEFAULT：</code>表示找不到匹配规则时，就执行该recipe。  </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default:all</span><br><span class="line">.DEFAULT:</span><br><span class="line">	commands</span><br></pre></td></tr></table></figure></div>
<p>这里当执行<code>make default</code> 时会转到<code>make all</code> 因为default：all 这个target没有隐式规则。所以最后会执行commands。</p>
</li>
<li><p>忽略命令的出错，可以在Makefile的命令行前加一个减号”-“(在Tab键之后)，标记为不管命令出不出错都认为是成功的。如：     </p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean:        </span><br><span class="line">	-(rm -f *.o )</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>include filename</code> 将filename中的内容导入，如果找不到会停止make， <code>-include filename</code> 则不会停止make。 </p>
</li>
</ol>
</li>
</ol>
<h2 id="几种等号"><a href="#几种等号" class="headerlink" title="几种等号"></a>几种等号</h2><p>= 是最基本的赋值<br>:= 是覆盖之前的值<br>?= 是如果没有被赋值过就赋予等号后面的值<br>+= 是添加等号后面的值</p>
<p>=与:= 的区别</p>
<p> =：make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。例子为：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">makefile</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x = foo</span><br><span class="line">y = <span class="variable">$(x)</span> bar</span><br><span class="line">x = xyz</span><br></pre></td></tr></table></figure></div>
<p>y的值将会是 xyz bar ，而不是 foo bar 。因为展开后最终变成的是xyz</p>
<p>:=表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">makefile</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">x := foo</span><br><span class="line">y := <span class="variable">$(x)</span> bar</span><br><span class="line">x := xyz</span><br></pre></td></tr></table></figure></div>
<p>y的值将会是 foo bar ，而不是 xyz bar 了。</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/02/make.html</a></li>
<li><a href="https://gist.github.com/isaacs/62a2d1825d04437c6f08" target="_blank" rel="noopener">https://gist.github.com/isaacs/62a2d1825d04437c6f08</a> makefile文件教程</li>
<li><a href="https://www.gnu.org/software/make/manual/make.html" target="_blank" rel="noopener">https://www.gnu.org/software/make/manual/make.html</a> GNUmake手册</li>
<li><a href="https://blog.csdn.net/shouso888/article/details/7226030" target="_blank" rel="noopener">https://blog.csdn.net/shouso888/article/details/7226030</a> 等号解释</li>
</ol>
]]></content>
      <categories>
        <category>编程语言</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令学习之wc</title>
    <url>/Linux%20%E5%91%BD%E4%BB%A4%20%E5%AD%A6%E4%B9%A0.html</url>
    <content><![CDATA[<h1 id="Linux-命令学习wc命令"><a href="#Linux-命令学习wc命令" class="headerlink" title="Linux 命令学习wc命令"></a>Linux 命令学习wc命令</h1><h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a><code>wc</code>命令</h2><a id="more"></a>
<ol>
<li>作用：Word Count 功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。 </li>
<li>格式：<ul>
<li><code>wc [option] filepath</code></li>
</ul>
</li>
<li>参数<ul>
<li><code>-c</code> 统计字节数</li>
<li><code>-l</code> 统计行数</li>
<li><code>-m</code> 统计字符数 标志不能与 -c 标志一起使用。 </li>
<li><code>-w</code> 统计字（单词word）数。一个字被定义为由空白、跳格或换行字符分隔的字符串 </li>
<li><code>-L</code>  打印最长行的长度。 </li>
<li><code>-help</code> 显示帮助信息 </li>
<li><code>--version</code> 显示版本信息 </li>
</ul>
</li>
<li>参考网址：<a href="http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html" target="_blank" rel="noopener">http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>tee命令解析</title>
    <url>/tee%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90.html</url>
    <content><![CDATA[<h1 id="make-2-gt-amp-1-tee-log-txt-命令解析"><a href="#make-2-gt-amp-1-tee-log-txt-命令解析" class="headerlink" title="make 2&gt;&amp;1 | tee log.txt 命令解析"></a>make 2&gt;&amp;1 | tee log.txt 命令解析</h1><p>在安装mpich 的时候遇到了很多这个命令，此处学习下这个命令：<code>2&gt;&amp;1 | tee log.txt</code> </p>
<a id="more"></a>
<p>这个命令共有三个部分： <code>2&gt;&amp;1</code> <code>|</code>  <code>tee log.txt</code></p>
<h2 id="2-gt-amp-1"><a href="#2-gt-amp-1" class="headerlink" title="2&gt;&amp;1"></a>2&gt;&amp;1</h2><p>shell中：最常使用的 FD (file descriptor) 大概有三个 </p>
<p>0表示标准输入Standard Input (STDIN)  </p>
<p>1表示标准输出Standard Output (STDOUT)  </p>
<p> 2表示标准错误输出 Standard Error Output (STDERR)  </p>
<p>‘&gt;’ 默认为标准输出重定向 （类似于c++ 中的 &gt;&gt;？）</p>
<p>在标准情况下, 这些FD分别跟如下设备关联 </p>
<p>stdin(0): keyboard  键盘输入,并返回在前端   </p>
<p>stdout(1): monitor  正确返回值 输出到前端   </p>
<p>stderr(2): monitor 错误返回值 输出到前端  </p>
<p>1&gt;&amp;2  正确返回值传递给2输出通道 &amp;2表示2输出通道   如果此处错写成 1&gt;2, 就表示把1输出重定向到文件2中  2&gt;&amp;1 错误返回值传递给1输出通道, 同样&amp;1表示1输出通道.  </p>
<h2 id="管道"><a href="#管道" class="headerlink" title="|管道"></a>|管道</h2><p>管道的作用是提供一个通道，将上一个程序的标准输出重定向到下一个程序作为下一个程序的标准输入。 </p>
<h2 id="tee-log-txt"><a href="#tee-log-txt" class="headerlink" title="tee log.txt"></a>tee log.txt</h2><p>tee从标准输入中读取，并将读入的内容写到标准输出以及文件中。  此处将数据读入并写入到log.txt中</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个命令将标准错误输出重定向到标准输出，然后再将标准输出重定向到log.txt文件中</p>
<p>常用于make 后面将log信息保存下来。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title>BigdataBench deploy</title>
    <url>/BigdataBench-deploy.html</url>
    <content><![CDATA[<h1 id="Bigdatabench-4-0-MPI版本-安装"><a href="#Bigdatabench-4-0-MPI版本-安装" class="headerlink" title="Bigdatabench 4.0 MPI版本 安装"></a>Bigdatabench 4.0 MPI版本 安装</h1><a id="more"></a>
<p>官网上面的指南BigDataBench User Manual有一些错误。</p>
<p>本机环境：</p>
<p>​    Centos 6.9</p>
<p>​    gcc (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>
<p>​    g++ (GCC) 4.8.2 20140120 (Red Hat 4.8.2-15)</p>
<h2 id="mpi的安装"><a href="#mpi的安装" class="headerlink" title="mpi的安装"></a>mpi的安装</h2><p>这部分网上资料很多，而Manual中有一点错误</p>
<ol>
<li><p>需要保证c 编译器 如gcc c++ 编译器 如：g++</p>
</li>
<li><p>基础安装</p>
<ol>
<li>从官网下载安装包解压</li>
</ol>
<ul>
<li><code>wget http://www.mpich.org/static/downloads/3.2.1/mpich-3.2.1.tar.gz</code>  从官网下载安装包</li>
<li><code>tar -zxvf mpich-3.2.1.tar.gz</code>  解压</li>
<li><code>cd mpich-3.2.1</code></li>
</ul>
<ol>
<li>配置安装目录   本机安装在mpich-install目录下</li>
</ol>
<ul>
<li><code>./configure –prefix=/home/mpich-install 2&gt;&amp;1 | tee c.txt</code> 手册中&amp;被错写为$了 <code>2&gt;&amp;1 | tee c.txt</code> 表示将输出的标准出错信息重定向到c.txt中。</li>
</ul>
<ol>
<li>build</li>
</ol>
<ul>
<li><code>make 2&gt;&amp;1 | tee m.txt</code></li>
</ul>
<ol>
<li>安装</li>
</ol>
<ul>
<li><code>make install 2&gt;&amp;1 | tee mi.txt</code></li>
</ul>
<ol>
<li>将安装目录添加到PATH 环境变量中</li>
</ol>
<ul>
<li><code>vim ~/.bashrc</code></li>
<li><code>export PATH=$PATH:/home/mpich-install/bin</code> 在最后一行添加</li>
<li><code>source ~/.bashrc</code> 重启生效</li>
</ul>
</li>
<li><p>检查</p>
<ol>
<li>检查路径<ul>
<li><code>which mpicc</code> </li>
<li><code>which mpic++</code></li>
</ul>
</li>
</ol>
</li>
<li><p>验证 </p>
<p>在mpich的安装包目录下有提供例子程序运行</p>
<ol>
<li><code>cd mpich-3.2.1/examples</code></li>
<li><code>mpicc cpi.c -o cpi</code> 编译cpi.c程序求pi值</li>
<li><code>mpirun -n 4 ./cpi</code> 使用4个进程 注意<code>./</code>否则报错找不到文件</li>
</ol>
<p>如果是集群环境在每个节点将mpich安装在相同的路径然后编辑一个machine_file （里面是各个节点的host）然后<code>mpirun -f machine_file -n 3 ./cpi</code> 在集群上并行运行</p>
</li>
</ol>
<h2 id="boost-安装"><a href="#boost-安装" class="headerlink" title="boost 安装"></a>boost 安装</h2><p>boost当前最新版本是：1.67 但是BigdataBench用的是1.43版本推荐安装这个旧版本</p>
<ol>
<li><p><code>wget https://sourceforge.net/projects/boost/files/boost/1.43.0/boost_1_43_0.tar.gz/download</code> </p>
</li>
<li><p>若下载下来的文件名为：downloads 则使用mv命令重命名在当前文件目录下:</p>
<p><code>mv downloads boost_1_43_0.tar.gz</code>  </p>
</li>
<li><p>解压<code>tar -zxvf boost_1_43_0.tar.gz</code>  之后<code>cd boost_1_43_0</code></p>
</li>
<li><p><code>sh bootstrap.sh</code>  执行这个命令运行脚本后会多出很多配置文件</p>
</li>
<li><p>使用mpi,这一步骤很重要否则后续cmake时会提示找不到：boost_mpi</p>
<ol>
<li><p>对低版本的boost </p>
<ol>
<li><p><code>which mpic++</code> 找mpich的目录</p>
</li>
<li><p><code>vim tools/build/v2/user-config.jam</code></p>
</li>
<li><p>在最后添加： using mpi:后面是mpich的目录</p>
<p><code>#MPI config</code></p>
<p><code>using mpi : /usr/lib64/mpich/bin/mpic++ ;</code></p>
</li>
</ol>
</li>
<li><p>对高版本的boost直接在boost_1_67_0目录下修改project-config.jam即可</p>
</li>
</ol>
</li>
<li><p><code>./bjam</code> 进行编译</p>
</li>
<li><p><code>./bjam install</code> 这一步是必需的但在手册中没有表明。</p>
</li>
</ol>
<h2 id="BigdataBench的配置"><a href="#BigdataBench的配置" class="headerlink" title="BigdataBench的配置"></a>BigdataBench的配置</h2><p>进入BigDataBench的安装根目录：</p>
<ol>
<li><code>vim conf.properties</code> 添加$JAVA_HOME， $MPI_HOME ，$BigdataBench_HOMEMPI的路径</li>
<li><code>sh prepar.sh</code> </li>
</ol>
<p>至此安装理论上已经成功。但仍然遇到了其他问题</p>
<h2 id="Perminsion-denied问题"><a href="#Perminsion-denied问题" class="headerlink" title="Perminsion denied问题"></a>Perminsion denied问题</h2><p>最开始的安装包是从windows下面考过去的结果生成cc的数据后无法运行执行脚本</p>
<p><a href="BigdataBench-deploy\runcc.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="BigdataBench-deploy\runcc.png" class="lazyload"></a></p>
<p>原因是此时的run_connectedComponents已经不是可执行文件了（不是绿色的）需要<code>chmod a+x run_connectedComponents</code>来将文件的权限修改为可执行文件权限（修改后变为绿色）</p>
<p>后面wget下载后解压配置之后直接就是可执行文件！</p>
<h2 id="ldd-程序-动态链接库缺失"><a href="#ldd-程序-动态链接库缺失" class="headerlink" title="ldd 程序 动态链接库缺失"></a>ldd 程序 动态链接库缺失</h2><p><code>[root@hw073 ConnectedComponent]# ldd run_connectedComponents</code><br><code>linux-vdso.so.1 =&gt;  (0x00007ffdfc8d4000)</code><br><code>librt.so.1 =&gt; /lib64/librt.so.1 (0x0000003156e00000)</code><br><code>libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x0000003156a00000)</code></p>
<p><code>libboost_serialization-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_filesystem-mt.so.1.43.0 =&gt; not found</code><br><code>libboost_system-mt.so.1.43.0 =&gt; not found</code><br><code>libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x0000003162200000)</code><br><code>libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003157200000)</code><br><code>libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x0000003161a00000)</code><br><code>libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003156600000)</code><br><code>/lib64/ld-linux-x86-64.so.2 (0x0000003155e00000)</code></p>
<p>最开始以为是没有指定LD_LIBRARY_PATH ，因为明明有这个文件的，后面使用find / -name 命令发现还是找不到，仔细一看ldd 的信息，发现上述文件都多了个-mt</p>
<p>解决办法： 在boost安装时的库。本机：<code>/usr/local/lib</code> 有着及其相似的3个文件<code>libboost_filesystem.so.1.43.0</code> 、<code>libboost_filesystem.so.1.43.0</code> ，<code>libboost_system.so.1.43.0</code> 均少了个-mt，因此将上述三个文件均拷贝一份命名为上述缺少的动态库文件。</p>
<p><code>cd /usr/local/lib</code> #切换到对应的目录下</p>
<p><code>cp libboost_system.so.1.43.0 libboost_system-mt.so.1.43.0</code> #拷贝为对应的文件名</p>
]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>bigdatabench</tag>
      </tags>
  </entry>
  <entry>
    <title>图计算常用算法</title>
    <url>/%E5%9B%BE%E8%AE%A1%E7%AE%97%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.html</url>
    <content><![CDATA[<h1 id="图算法的典型操作"><a href="#图算法的典型操作" class="headerlink" title="图算法的典型操作"></a>图算法的典型操作</h1><p>关于一些常见图算法的调研与学习。</p>
<a id="more"></a>
<h2 id="常用图算法"><a href="#常用图算法" class="headerlink" title="常用图算法"></a>常用图算法</h2><h3 id="PageRank"><a href="#PageRank" class="headerlink" title="PageRank"></a>PageRank</h3><ol>
<li><p>背景    </p>
<ol>
<li>既考虑入链数量，又考虑了网页质量因素，二者相结合 数量与权重的结合</li>
<li>算法与主题无关，因为PR值是根据图计算出来的</li>
</ol>
</li>
<li><p>算法原理</p>
<ol>
<li><p>基本思想</p>
<p>A有链接指向B，表明A认为B比A重要。A将自身权重分配一部分给B。</p>
<p>$W(B)=W(A)/N$   W(A) 是A的PR值，W(B)是A 分配的权重，N是A的出链数</p>
</li>
<li><p>PageRank公式修正</p>
<p>存在出链为0的孤立网页，增加阻力系数q ，一般取q=0.85，其意义是用户有1-q的概率不点击此页面上面的所有链接。同时还有随机直接跳转的概率，如直接输入网址，点击书签等。完整公式如下：</p>
<p><a href="E:\data\ict\docs\page rank.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="E:\data\ict\docs\page rank.png" class="lazyload"></a></p>
</li>
</ol>
</li>
</ol>
<h3 id="Connected-component"><a href="#Connected-component" class="headerlink" title="Connected component"></a>Connected component</h3><ol>
<li>定义<ol>
<li>连通分支：图中，某个子图的任意两点有边连接，而子图之间无边连接</li>
<li>问题：cc是寻找连通分支的算法？？</li>
</ol>
</li>
<li>通过BFS、DFS算法的便利就可以找到连通分支，每个白色节点开始的就是一个连通分支。</li>
<li>常见算法<ol>
<li>DFS<ol>
<li>原理：访问某个顶点后只有当某个节点是叶结点后才会访问其余相邻节点。</li>
<li>步骤：<ol>
<li>选择一个结点作为起始结点，标记为灰色</li>
<li>从该节点的邻居结点中选择一个结点，标记为灰色，继续这个操作</li>
<li>当选中的结点时叶子结点时，将其涂黑并返回到上一个父节点。</li>
<li>重复2,3直到所有结点都被访问。</li>
</ol>
</li>
</ol>
</li>
<li>BFS   （DFS，BFS不是图的遍历算法吗）。<ol>
<li>原理：在进一步遍历中顶点之前，先访问当前结点的所有邻接结点。</li>
<li>步骤：<ol>
<li>选择一个顶点作为起始节点，放入队列，标记为灰色，其余标记为白色</li>
<li>寻找队列首部结点的所有邻居节点，将其放入队列中并标记为灰色，将队列首部结点出队，并标记为黑色  </li>
<li>重复2步骤，直到队列中的节点全部为空。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="SSSP-single-source-shortest-paths"><a href="#SSSP-single-source-shortest-paths" class="headerlink" title="SSSP (single-source shortest paths)"></a>SSSP (single-source shortest paths)</h3><ol>
<li>单独的起点与目标点之间最短路径的计算。起点固定，寻找与其他所有结点之间的最短路径。包括单源单汇，单源多汇</li>
<li>常见算法<ol>
<li>Dijkstra<ol>
<li>步骤<ol>
<li>将所有顶点分成两个集合A、B，其中集合A表示已经求得从V0出发的最短路径的顶点集合，集合B为为待求解的顶点集合。初始时有A={V0}</li>
<li>将集合A与集合B相连的边（A中的所有结点与B中所有的结点形成的边）按照从V0出发的最短权重和递增次序排序，取最短的边，将该条边在集合B中所对应的顶点加入到集合A中</li>
<li>重复第二步，直至B为空集。</li>
</ol>
</li>
<li>总结：<ol>
<li>最短中的最短：每次迭代时比较的是当前状态下以V0为起点，A中顶点为中间点的到各顶点之间的最短路径权重，最后再选择在当前所有最短路径中路径最短的一个顶点加入A。也就是说每次加入A集合的点是最短路径中的最短。</li>
<li>给定目标点，在每次迭代时，并不知道能否到达最后的目标点，所以把到所有结点的最短距离都算出来了。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Betweenness-Centrality（中介中心性）"><a href="#Betweenness-Centrality（中介中心性）" class="headerlink" title="Betweenness Centrality（中介中心性）"></a>Betweenness Centrality（中介中心性）</h3><ol>
<li><p>定义 ：中心性用来衡量节结点的重要性。Betweenness Centrality ：考虑的是该节点出现在其他两节点之间的最短路径上的比率。</p>
</li>
<li><p>思想：如果一个成员位于其他成员的多条最短路上，那么该成员就是核心成员，就具有较大的中介中心性。</p>
</li>
<li><p>步骤</p>
<p>其中<a href="https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png" data-fancybox="group" data-caption="\sigma_{st}" class="fancybox"><img alt="\sigma_{st}" title="\sigma_{st}" data-src="https://i2.wp.com/upload.wikimedia.org/math/b/b/7/bb79bd91213d03edf0c8fc04fbd51085.png" class="lazyload"></a>表示的是节点s和t之间的最短路径的数量，而<a href="https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png" data-fancybox="group" data-caption="\sigma_{st}(v)" class="fancybox"><img alt="\sigma_{st}(v)" title="\sigma_{st}(v)" data-src="https://i2.wp.com/upload.wikimedia.org/math/4/2/c/42c33f5f78864175f0d9c9af1c492f5d.png" class="lazyload"></a>是最短路径中经过节点v的数量。</p>
<ol>
<li><p>计算各个点对之间最短路径的长度和条数，用于计算pair-dependencies: δst(v) =σst(v)/σst</p>
<p><a href="http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg" data-fancybox="group" data-caption="clip_image004" class="fancybox"><img alt="clip_image004" title="clip_image004" data-src="http://static.oschina.net/uploads/img/201305/11121047_IQnh.jpg" class="lazyload"></a></p>
</li>
<li><p>对于每个节点，累积属于自己的pair-dependencies</p>
</li>
</ol>
<p><a href="https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://i2.wp.com/upload.wikimedia.org/math/4/c/c/4cc6eaa2dce9d504feeed5bd88b96d73.png" class="lazyload"></a></p>
</li>
</ol>
<h3 id="LBP算法-Local-Binary-Pattern-局部二值模式"><a href="#LBP算法-Local-Binary-Pattern-局部二值模式" class="headerlink" title="LBP算法(Local Binary Pattern, 局部二值模式)"></a>LBP算法(Local Binary Pattern, 局部二值模式)</h3><ol>
<li><p>定义：LBP是一种用来描述图像局部纹理特征的算子。</p>
<ol>
<li>原始的LBP算子定义为在3*3的窗口内，以窗口中心像素为阈值，将相邻的8个像素的灰度值与其进行比较，若周围像素值大于中心像素值，则该像素点的位置被标记为1，否则为0</li>
</ol>
<p><a href="http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="http://hi.csdn.net/attachment/201104/13/0_1302700245WllL.gif" class="lazyload"></a></p>
</li>
<li><p>作用是进行特征提取，而且，提取的特征是图像的纹理特征，并且，是局部的纹理特征.</p>
</li>
<li><p>改进版本</p>
<ol>
<li>原型LBP算子 </li>
<li>LBP等价模式</li>
</ol>
</li>
</ol>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><ol>
<li>定义：无环连通图，图中所有结点均参与，所有边的权重加起来最小。</li>
<li>算法<ol>
<li>Prim算法  <ol>
<li>步骤：设N=(V,{E})是连通网， TE是N上最小生成树中边的集合 <ol>
<li>初始令U={u0},(u0V), TE=φ</li>
<li>在所有uU,vV-U的边(u,v)E中，找一条代价最小<br>的边(u0,v0), 并保证不形成回路 </li>
<li>将(u0,v0)并入集合TE，同时v0并入U </li>
<li>重复上述操作直至U=V为止，则T=(V,{TE})为N的<br>最小生成树  </li>
</ol>
</li>
<li>总结：每次迭代加入所有连通边中权值最小的。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="三角计数"><a href="#三角计数" class="headerlink" title="三角计数"></a>三角计数</h3><ol>
<li>定义：寻找无向图中的所有三角形</li>
<li>步骤<ol>
<li>建立邻接表：<ol>
<li>如果A-B &amp; A &lt; B，则将B加入A的邻接表 如果A-B &amp; B &lt; A，则将A加入B的邻接表  A&lt;B比较的是id</li>
</ol>
</li>
<li>遍历每个节点，对于结点A，遍历A邻接表中的结点，如果邻接结点B,C两两之间存在边，则A、B、C三者之间存在三角形</li>
</ol>
</li>
</ol>
<h3 id="社区发现"><a href="#社区发现" class="headerlink" title="社区发现"></a>社区发现</h3><ol>
<li><p>社区定义：同一社区内的节点与节点之间的连接很紧密，而社区与社区之间的连接比较稀疏。社区是一个子图</p>
</li>
<li><p>数学描述：<a href="https://img-blog.csdn.net/20130710080910046" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://img-blog.csdn.net/20130710080910046" class="lazyload"></a></p>
</li>
<li><p>衡量标准：模块度</p>
<ol>
<li>计算公式</li>
</ol>
<p><a href="https://img-blog.csdn.net/20130710081032203" data-fancybox="group" data-caption="" class="fancybox"><img alt="" title="" data-src="https://img-blog.csdn.net/20130710081032203" class="lazyload"></a></p>
</li>
<li><p>常见算法</p>
<ol>
<li>GN算法<ol>
<li>思想：在一个网络之中，通过社区内部的边的最短路径相对较少，而通过社区之间的边的最短路径的数目则相对较多。从社区内部走大概率会走很多条边。</li>
<li>步骤<ol>
<li>计算每一条边的边介数。边介数（betweenness）：网络中任意两个节点通过此边的最短路径的数目。</li>
<li>删除边介数最大的边</li>
<li>重复（1）（2），直到网络中的任一顶点作为一个社区为止。</li>
</ol>
</li>
<li>缺陷<ol>
<li>不知道最后会有多少个社区</li>
<li>在计算边介数的时候可能会有很对重复计算最短路径的情况，时间复杂度太高</li>
<li>GN算法不能判断算法终止位置</li>
</ol>
</li>
</ol>
</li>
<li>LPA算法（标签传播算法）<ol>
<li>思路<ol>
<li>自己是什么标签，由邻居决定。邻居中什么标签最多，则此结点是什么标签</li>
</ol>
</li>
<li>步骤<ol>
<li>为所有结点指定一个唯一的标签</li>
<li>逐轮刷新所有结点的标签，直到达到收敛要求位置。刷新规则： 对于某一个节点，考察其所有邻居节点的标签，并进行统计，将出现个数最多的那个标签赋给当前节点。当个数最多的标签不唯一时，随机选一个。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ol>
<li>定义 ：<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。且该序列必须满足下面两个条件：<ol>
<li>每个顶点出现且只出现一次</li>
<li>若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面</li>
</ol>
</li>
<li>步骤<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出</li>
<li>从图中删除该顶点和所有以它为起点的有向边</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环<br><a href="http://img.blog.csdn.net/20150507001759702" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" title="img" data-src="http://img.blog.csdn.net/20150507001759702" class="lazyload"></a></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title>ceph 部署文档</title>
    <url>/ceph%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3.html</url>
    <content><![CDATA[<h1 id="ceph-部署文档"><a href="#ceph-部署文档" class="headerlink" title="ceph 部署文档"></a>ceph 部署文档</h1><a id="more"></a>
<hr>
<h1 id="1-配置所有节点"><a href="#1-配置所有节点" class="headerlink" title="1.配置所有节点"></a>1.配置所有节点</h1><h2 id="创建ceph用户"><a href="#创建ceph用户" class="headerlink" title="创建ceph用户"></a>创建ceph用户</h2><h2 id="安装配置NTP"><a href="#安装配置NTP" class="headerlink" title="安装配置NTP"></a>安装配置NTP</h2><ol>
<li><code>systemctl enable ntp</code>  ubuntu 14.04不可用，感觉已经安装过了，因此跳过。</li>
</ol>
<h2 id="配置hosts文件"><a href="#配置hosts文件" class="headerlink" title="配置hosts文件"></a>配置hosts文件</h2><p><code>172.16.1.93 object1</code><br><code>172.16.1.94 object2</code><br><code>172.16.1.95 object3</code><br><code>172.16.1.66 object4</code><br><code>172.16.1.92 controller</code></p>
<hr>
<h1 id="2-配置ssh服务器"><a href="#2-配置ssh服务器" class="headerlink" title="2. 配置ssh服务器"></a>2. 配置ssh服务器</h1><p>修改ssh的配置文件</p>
<p>Host controller<br>        Hostname gd92<br>        User cephuser<br>Host object1<br>        Hostname gd93<br>        User cephuser<br>Host object2<br>        Hostname hw101<br>        User cephuser<br>Host object3<br>        Hostname gd95<br>        User cephuser<br>Host object4<br>        Hostname gd66<br>        User cephuser</p>
<p>生成密钥并拷贝到4个osd节点上，无需拷贝到controller节点</p>
<hr>
<h1 id="3-安装ceph"><a href="#3-安装ceph" class="headerlink" title="3.安装ceph"></a>3.安装ceph</h1><p>主要参考链接：这些链接的操作大都一致，部分的顺序会有变化。</p>
<p><a href="https://linux.cn/article-8182-1.html#4_10238" target="_blank" rel="noopener">https://linux.cn/article-8182-1.html#4_10238</a></p>
<p><a href="https://blog.csdn.net/styshoo/article/details/55471132" target="_blank" rel="noopener">https://blog.csdn.net/styshoo/article/details/55471132</a></p>
<p><a href="https://blog.csdn.net/styshoo/article/details/58572816" target="_blank" rel="noopener">https://blog.csdn.net/styshoo/article/details/58572816</a></p>
<h2 id="部署监控节点出现的问题"><a href="#部署监控节点出现的问题" class="headerlink" title="部署监控节点出现的问题"></a>部署监控节点出现的问题</h2><p><code>ceph-deploy mon create-initial</code></p>
<ol>
<li><p><code>ceph-mon --cluster ceph --mkfs -i gd92 --keyring /var/lib/ceph/tmp/ceph-gd92.mon.keyring</code></p>
<p>问题：ceph.conf的配置文件中的<code>public network=172.16.1.92/24</code> 掩码前面多打了空格</p>
<p>修改后重新执行命令，并加上<code>--overwrite-conf</code> </p>
</li>
<li><p>[info]Running command: ceph —cluster=ceph —admin-daemon /var/run/ceph/ceph-mon.controller.asok mon_status</p>
<p><code>admin_socket: exception getting command descriptions: [Errno 2] No such file or directory</code></p>
<p>似乎是ceph -deploy 的问题，或者是ubuntu14.04的问题。教程是ubuntu16.04的</p>
<p>此问题非hostname 不对应</p>
<p>非conf 不同步导致。—overwrtie-conf  无作用。</p>
<p>解决办法：按照14.04方法重新安装ceph-deploy</p>
</li>
</ol>
<h2 id="部署osd节点出现的问题"><a href="#部署osd节点出现的问题" class="headerlink" title="部署osd节点出现的问题"></a>部署osd节点出现的问题</h2><ol>
<li>使用<code>ceph-deploy disk list ceph-osd1 ceph-osd2 ceph-osd3</code>检查磁盘可用性时报错，使用<code>ceph-deploy osd prepare ceph-osd1:/dev/sdb ceph-osd2:/dev/sdb ceph-osd3:/dev/sdb</code> 在数据盘上面准备时也报错<br>Running command: fdisk -l  File “/usr/lib/python2.7/distpackages/ceph_deploy/util/decorators.py”, line 69, in newfunc<br>问题：未知<br>解决办法：将osd节点的数据目录放在指定目录，不用整个数据盘</li>
<li>最后部署后集群状况是health -ok，但是4osds，有3个osd up，一个osd down<br>问题：down掉的节点磁盘有问题。<br>解决办法：先卸载磁盘，重新格式化，挂载，重新激活osd节点</li>
</ol>
<h2 id="部署rgw节点出现的问题"><a href="#部署rgw节点出现的问题" class="headerlink" title="部署rgw节点出现的问题"></a>部署rgw节点出现的问题</h2><ol>
<li><p>显示rgw进程在工作，但是使用：<a href="http://controller:7480" target="_blank" rel="noopener">http://controller:7480</a> 显示拒绝连接。并且新建S3账号，测试时未返回正确结果。</p>
<p>问题：未知</p>
<p>尝试方法：重新部署</p>
<p>解决办法：重新部署后最开始将端口设置为80，发现可以创建s3账号，但是无法正确测试，显示创建bucket出错，查看rgw的log，发现端口被占用，无法打开，后面重新设置端口为7480问题解决，测试均正确。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>deploy</category>
      </categories>
      <tags>
        <tag>ceph</tag>
      </tags>
  </entry>
</search>
