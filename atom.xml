<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>饱腹百科</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkcl.github.io/"/>
  <updated>2020-11-22T03:31:30.396Z</updated>
  <id>https://kkcl.github.io/</id>
  
  <author>
    <name>饱腹百科</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的多线程</title>
    <link href="https://kkcl.github.io/Java/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://kkcl.github.io/Java/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-11-22T03:22:54.423Z</published>
    <updated>2020-11-22T03:31:30.396Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个后端程序员，尤其是一名主力编程语言为Java的程序员而言，多线程始终是一道迈不过去的坎，就像大国各自的原子弹一样，虽然不用但是不能没有，同样多线程虽然在日常的编码中几乎很少涉及，但也不是说没有应用。<a id="more"></a>如果你的回答是没有接触过相关的业务场景，不是你从事的项目过于低端，就是你的公司业务确实没必要涉及到相关的业务开发，但无论如何，即使日常开发不用，并不代表你可以偷懒不掌握，否则下次跳槽的时候可能会被打击的体无完肤。</p><h3 id="多线程的含义"><a href="#多线程的含义" class="headerlink" title="多线程的含义"></a>多线程的含义</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个后端程序员，尤其是一名主力编程语言为Java的程序员而言，多线程始终是一道迈不过去的坎，就像大国各自的原子弹一样，虽然不用但是不能没有，同样多线程虽然在日常的编码中几乎很少涉及，但也不是说没有应用。
    
    </summary>
    
    
      <category term="Java基本功" scheme="https://kkcl.github.io/categories/Java%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="Java" scheme="https://kkcl.github.io/tags/Java/"/>
    
      <category term="多线程" scheme="https://kkcl.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>懂王，我的世界不存在认输！</title>
    <link href="https://kkcl.github.io/wechat/%E6%87%82%E7%8E%8B%EF%BC%8C%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%AE%A4%E8%BE%93/"/>
    <id>https://kkcl.github.io/wechat/%E6%87%82%E7%8E%8B%EF%BC%8C%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%AE%A4%E8%BE%93/</id>
    <published>2020-11-21T07:55:48.776Z</published>
    <updated>2020-11-21T08:06:07.422Z</updated>
    
    <content type="html"><![CDATA[<p>​距离大洋彼岸美国的总统大选结果已经过去一段时间了，最终结果也如大部分消息人士所预期的那样，民主党人拜登成功拿下总统之位。但截至到目前为止，共和党人现任总统特朗普依然没有承认败选的迹象。<a id="more"></a>对于选举结果，一如既往的在社交媒体平台发挥他那天马行空的想象力，不是指责媒体宣告的拜登胜选是个”假新闻”就是控诉选举过程中存在邮寄选票作弊问题，诚然即使部分选区可能存在懂王所声称的存在舞弊的问题，但是在巨大的选票差距面前，懂王的体面下台似乎只是一个时间问题。明年权力交接日期之后，一代懂王可能将会在这个你方登罢，我方上场的世界大舞台退幕。回望过去的4年，懂王带给了我们太多的欢乐，值此即将临别谢幕之际值得我们一起回顾属于懂王的光辉岁月。</p><p>懂王1946年出生于一个德裔美国家庭中，父亲名叫弗雷德.特朗普，不过懂王一家真正跟大洋彼岸的灯塔国扯上关系可得从懂王的祖父讲起。将时间拨回到19世纪80年代，彼时的欧洲进入了普遍的经济停滞和衰退，为了摆脱困苦的家庭环境，同时为了逃脱德国的兵役制度，年轻的特朗普祖父踏上了前往灯塔国淘金的征程，虽然路途一路艰险，不过好在年轻的弗里德里希.特朗普(特朗普祖父)最终平安的抵达了纽约。因为最初的几年不会英语的原因，弗里德里希.特朗普在前期抵达的姐姐家里一住就是好几年，这几年中年轻的弗里德里希.特朗普一直靠给人理发维持生计，随后在灯塔国淘金热的热潮下，为了追逐财富，弗里德里希.特朗普决定前往灯塔国西部碰碰运气，不过这一次，特朗普的祖父并没有选择继续从事的他的老行当理发行业，而是选择投入一个新的行业——餐饮业和旅馆业，瞄准的人群就是那些蜂拥到西部淘金的人。这样的事业一干就是8年，等到20世纪初期，特朗普祖父的净资产已经达到了惊人的50万美元。</p><p>积累到足够的财富之后，特朗普祖父一心荣归故里，并在回乡期间与邻居的女儿结成了夫妻，短暂的停留之后再次返回灯塔国，可能是因为故土难迁的思乡感，无论是特朗普祖父还是他的妻子，两人都主张回到故乡，可没有想到的是1905年，德国地方政府以20年前逃离服兵役事件，特朗普祖父被勒令指定期限之前必须离开德国，从那以后，特朗普祖父就再也没有重新踏足于德国故乡，直至1918年死于流感，此时特朗普的父亲还未成年。</p><p>相比特朗普的祖父，虽然特朗普父亲的人生经历中缺少颠沛流离的人生经历，不过论商业头脑，丝毫不逊色与自己的父亲。大萧条时期，抓住纽约市房地产的市场变化，针对特定人群迅速推出售价3990美元的独立住宅，同时通过广告不断推广与住宅区配套的个人超市，仅仅一年多的时间，就迅速回笼资金，并高价出售手头的超市资产，迅速积累个人资产财富。二战期间，又抓住沿海各大造船厂员工的需求，果断建造兵营和花园公寓，同时在战后迎合中低收入群体的需求，推出适合他们的个人房产，通过一系列的投资、资产运作，特朗普父亲迅速在房地产行业立住根基，此后在上世纪七十年代，特朗普进入父亲的公司，正式接管父亲商业地产王国，特朗普父亲卒于1999年，享年94岁，与自己的祖父相比，特朗普父亲可谓长寿。</p><p>特朗普在接手父亲的商业地产帝国之后，与其父亲相比，个人野心更大，1974年在纽约曼哈顿的“宾夕法尼亚中央铁路公司”宣告破产之后，特朗普立刻买下这块地产，同时1975年又以数千万美元的代价买下靠近纽约火车站的地产，通过这几件大型的商业地产收购案，特朗普迅速打响了自己在纽约的名气。再次之后，又将投资的触角不断的迈向赌场、航运、足球、职业拳击赛等领域。由于房地产基本盘的牢固，这些业务虽然短时间内没有盈利的能力，但凭借地产利润的输血，也不会对特朗普集团产生大的影响。</p><p>时间转眼来到上世纪90年代初期，由于美国房地产行业的不景气，特朗普的基本盘，房地产主营业务也不再稳固，受此影响最低谷时期特朗普的个人资产一度从17亿美元跌至5亿美元，同时还需要处理巨额的银行利息。</p><p>濒临破产边缘的多事之秋，特朗普不仅没有收敛他的花花公子个性，反而此时还在外面拈花惹草，纸始终是包不住火的，婚外情的桃色新闻一经媒体平台揭露，特朗普夫妇两人的美好婚姻形象迅速在外人面前毁灭，更糟糕的是随着桃色新闻的不断发酵，各大银行债主纷纷踏上门来，要求特朗普立刻偿还自己的债务，不过一番唇枪舌战之后，特朗普最终说服了债务人将负债转换为公司的股份。此后经过几年的修养生息，特朗普不仅成功还清个人的所有债务，同时也将各大银行的股份都回收了回来。在事业复苏的重要档口，特朗普再一次发挥了他那花花公子的的个性，在几乎没有任何媒体爆料的情形下，公开宣布与自己的第二任妻子玛拉.梅普尔斯离婚，此后又与自己的第三任妻子梅拉尼娅走入婚姻的殿堂。</p><p>与个人的婚姻相比，特朗普的政治生涯则一帆风顺。至于特朗普这样一个没有任何从政经验的人为什么会突然全力角逐总统的大位呢？恐怕还得从以下的几件小事讲起。</p><p>1999年，特朗普的父亲逝世，可也是在这的前一年，没有任何从政经验的特朗普好友，杰西.文图拉却突然当选为明尼苏达州的州长，此人在当选州长之前曾经是一名职业摔跤手，与特朗普相识于一场职业摔角赛，杰西的当选让特朗普终于安奈不住心中那颗躁动的心，此后特朗普频频与杰西来往，并在来往的过程中不断的询问对方的竞选策略，杰西的当选让特朗普忍不住浮想，或许有朝一日，自己也有可能成为美国的总统。至此之后，特朗普每逢大选年就会放出自己有意参选总统大选的风声，可每次却又出来澄清自己无意参与总统大选的表态，以至于很长的一段时间特朗普成为许多人的笑柄</p><p>同时由于过去几十年口无遮拦的坏毛病，特朗普经常喜欢对总统等重要人物评头论足，导致在无形中得罪了很多人。其中又因为评论奥巴马的出生问题，导致一度引起奥巴马的厌恶，最终，在2011年的奥巴马举办的一次晚会上，奥巴马狠狠的羞辱了特朗普一顿，最终使其沦为整场晚会的笑柄。也可能是因为这次晚会受到的羞辱，可能导致特朗普暗下决心定要拿下美国总统的宝座。</p><p>好不容易熬到奥巴马的任期结束，特朗普便马不停蹄的投入到2016年总统竞选的日程中，这一次他没有像以往那样，中途选择放弃。即使对手希拉里实力十分强劲，可凭借自身嘴上的得理不饶人的本领，一举抓住希拉里的邮件门事件揪住不放，最终成功胜选当选为美国总统。</p><p>成功当选为美国总统之后，特朗普不但性格方面没有丝毫的收敛，反而动不动的不是退群就是满世界收小弟们的保护费，尤其是在处理疫情方面，处理的应对措施简直可以用一波666来形容，于是在随后的岁月中什么鼓励民众喝消毒水、不带口罩、全体免疫、天气热了病毒会自动消失的荒诞言论层出不穷。美国人民摊上这样的一位总统，可谓是又苦说不出，不过好在特朗普的时间不多了，因为应对疫情的不当，美国的选民再一次用他们手中的选票成功的将拜登送入了白宫的大门，虽然特朗普到目前为止还是没有承认败选的动向，但是到最终的权力交接日，他肯定是会走人的。</p><p>特朗普执政四年，虽然没有什么惊天动地的政治成绩，但为无数的网友带来了无尽欢乐的源泉，无数网友真心希望他还能再干一届，至于大选之后特朗普究竟和去何处，恐怕只有时间能给与答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​距离大洋彼岸美国的总统大选结果已经过去一段时间了，最终结果也如大部分消息人士所预期的那样，民主党人拜登成功拿下总统之位。但截至到目前为止，共和党人现任总统特朗普依然没有承认败选的迹象。
    
    </summary>
    
    
      <category term="公众号文章" scheme="https://kkcl.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="wechat" scheme="https://kkcl.github.io/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>Java中IO相关的操作</title>
    <link href="https://kkcl.github.io/Java/Java%E4%B8%AD%E7%9A%84IO%E6%93%8D%E4%BD%9C/"/>
    <id>https://kkcl.github.io/Java/Java%E4%B8%AD%E7%9A%84IO%E6%93%8D%E4%BD%9C/</id>
    <published>2020-11-17T13:33:17.268Z</published>
    <updated>2020-11-21T07:48:18.058Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名后端开发工程师，在日常的开发中肯定会涉及到各种各样操作IO流相关的场景，IO从字面意思表示输入输出。按照IO流不同划分的标准，可将IO流划分为以下的几种类型。<a id="more"></a>从流的流向来分可划分为输入流(输入流指的是只能从中读取数据，而不能写入数据)和输出流(输入流指的是不能读取数据，只能写入数据)；</p><h3 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h3><ul><li><p>流向划分<br>输入流：只能从中读取数据，而不能向其写出数据。<br>输出流：只能向其写出数据，而不能从中读取数据。<br>输入流主要由InputStream和Reader作为基类。<br>输出流则主要由OutputStream和Writer作为基类</p></li><li><p>最小数据操作单元<br>字节流：字节流操作的最小数据单元是 8位的字节。<br>字符流：最小数据单元是 16位的字符。<br>字节流主要有InputStream和OutputStream作为基类。<br>字符流则主要由Reader和Writer作为基类。</p></li><li><p>流的角色<br>节点流：节点流可以从/向一个特定的IO设备(如磁盘、网络)读/写数据的流<br>处理流：已存在的流(节点流或处理流)进行连接或封装</p></li></ul><h3 id="IO流读取常用方法"><a href="#IO流读取常用方法" class="headerlink" title="IO流读取常用方法"></a>IO流读取常用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">public class FileUtils &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;**创建文件**&#x2F;</span><br><span class="line">    public static boolean createFile(String path) &#123;</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        File file &#x3D; new File(path);</span><br><span class="line">        if(!file.exists())&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                result &#x3D; file.createNewFile();</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**创建文件夹**&#x2F;</span><br><span class="line">    public static boolean createDirectory(String directory)&#123;</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        File file &#x3D; new File(directory);</span><br><span class="line">        if(!file.exists())&#123;</span><br><span class="line">            result &#x3D; file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**删除文件**&#x2F;</span><br><span class="line">    public static boolean deleteFile(String path) &#123;</span><br><span class="line">        boolean result &#x3D; false;</span><br><span class="line">        File file &#x3D; new File(path);</span><br><span class="line"></span><br><span class="line">        if(file.exists() &amp;&amp; file.isFile())&#123;</span><br><span class="line">            result &#x3D; file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**删除文件夹(包括子文件夹及文件)**&#x2F;</span><br><span class="line">    public static void deleteDirectory(String path) &#123;</span><br><span class="line">        File file &#x3D; new File(path);</span><br><span class="line">        if(!file.exists())&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(file.isFile())&#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;else if(file.isDirectory())&#123;</span><br><span class="line">            File [] files &#x3D; file.listFiles();</span><br><span class="line">            for(File f : files)&#123;</span><br><span class="line">                deleteDirectory(path + &quot;&#x2F;&quot; + f.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**采用字节方式读取文件**&#x2F;</span><br><span class="line">    public static String readFileByBytes(String path)&#123;</span><br><span class="line">        File file &#x3D; new File(path);</span><br><span class="line">        if(!file.exists() || !file.isFile())&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer content &#x3D; new StringBuffer();</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] temp &#x3D; new byte[1024];</span><br><span class="line">            FileInputStream fileInputStream &#x3D; new FileInputStream(file);</span><br><span class="line">            while(fileInputStream.read(temp) !&#x3D; -1)&#123;</span><br><span class="line">                content.append(new String(temp));</span><br><span class="line">                temp &#x3D; new byte[1024];</span><br><span class="line">            &#125;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return content.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**采用字符方式读取文件**&#x2F;</span><br><span class="line">    public static String readFileByChars(String path)&#123;</span><br><span class="line">        File file &#x3D; new File(path);</span><br><span class="line">        if(!file.exists() || !file.isFile())&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer content &#x3D; new StringBuffer();</span><br><span class="line">        try &#123;</span><br><span class="line">            char[] temp &#x3D; new char[1024];</span><br><span class="line">            FileInputStream fileInputStream &#x3D; new FileInputStream(file);</span><br><span class="line">            InputStreamReader inputStreamReader &#x3D; new InputStreamReader(fileInputStream, &quot;GBK&quot;);</span><br><span class="line">            while(inputStreamReader.read(temp) !&#x3D; -1)&#123;</span><br><span class="line">                content.append(new String(temp));</span><br><span class="line">                temp &#x3D; new char[1024];</span><br><span class="line">            &#125;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            inputStreamReader.close();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return content.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**按行读取文本文件的内容**&#x2F;</span><br><span class="line">    public static List&lt;String&gt; readFileByLines(String path) &#123;</span><br><span class="line">        File file &#x3D; new File(path);</span><br><span class="line">        if(!file.exists() || !file.isFile())&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; content &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            FileInputStream fileInputStream &#x3D; new FileInputStream(file);</span><br><span class="line">            InputStreamReader inputStreamReader &#x3D; new InputStreamReader(fileInputStream, &quot;GBK&quot;);</span><br><span class="line">            BufferedReader bufferedReader &#x3D; new BufferedReader(inputStreamReader);</span><br><span class="line">            String lineContent &#x3D; &quot;&quot;;</span><br><span class="line">            while((lineContent &#x3D; bufferedReader.readLine()) !&#x3D; null)&#123;</span><br><span class="line">                content.add(lineContent);</span><br><span class="line">            &#125;</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">            inputStreamReader.close();</span><br><span class="line">            bufferedReader.close();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**FileOutputStream写入文件**&#x2F;</span><br><span class="line">    public static void writeFileByFileOutputStream(String path, String content) &#123;</span><br><span class="line">        File file &#x3D; new File(path);</span><br><span class="line">        try&#123;</span><br><span class="line">            FileOutputStream fileOutputStream &#x3D; new FileOutputStream(path);</span><br><span class="line">            fileOutputStream.write(content.getBytes(&quot;GBK&quot;));</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**BufferFileOutputStream写入文件**&#x2F;</span><br><span class="line">    public static void writeFileByBufferFileOutputStream(String path, String content) &#123;</span><br><span class="line">        File file &#x3D; new File(path);</span><br><span class="line">        try&#123;</span><br><span class="line">            BufferedOutputStream bufferedOutputStream &#x3D; new BufferedOutputStream(new FileOutputStream(file));</span><br><span class="line">            bufferedOutputStream.write(content.getBytes());</span><br><span class="line">            bufferedOutputStream.flush();</span><br><span class="line">            bufferedOutputStream.close();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**FileWriter写入文件**&#x2F;</span><br><span class="line">    public static void writeFileByFileWriter(String path, String content)&#123;</span><br><span class="line">        File file &#x3D; new File(path);</span><br><span class="line">        try &#123;</span><br><span class="line">            FileWriter fileWriter &#x3D; new FileWriter(path);</span><br><span class="line">            fileWriter.write(content);</span><br><span class="line">            fileWriter.flush();</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件读取综合案例"><a href="#文件读取综合案例" class="headerlink" title="文件读取综合案例"></a>文件读取综合案例</h3><p>最后针对文件的举一个实际的运用场景，前端上传指定格式的文件，后端读取文件的二进制流，并针对文件的内容进行相关的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#submit&quot;).click(function () &#123;</span><br><span class="line"></span><br><span class="line">   var formData &#x3D; new FormData();</span><br><span class="line">   formData.append(&quot;file&quot;, $(&#39;#file&#39;)[0].files[0]);</span><br><span class="line">   formData.append(&quot;note&quot;, $(&quot;#note&quot;).val());</span><br><span class="line"></span><br><span class="line">   var ajaxUrl &#x3D; &quot;&#x2F;admin&#x2F;imei&#x2F;insertData&quot;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">       type: &quot;POST&quot;,</span><br><span class="line">       url: ajaxUrl,</span><br><span class="line">       data: formData,</span><br><span class="line">       processData: false,</span><br><span class="line">       contentType: false,</span><br><span class="line">       datatype: &quot;json&quot;,</span><br><span class="line">       success: function (data) &#123;</span><br><span class="line">           var responseData &#x3D; JSON.parse(data);</span><br><span class="line">           if (responseData.status &#x3D;&#x3D; &quot;success&quot;) &#123;</span><br><span class="line">               location.reload();</span><br><span class="line">               alert(&quot;提交成功&quot;)</span><br><span class="line">           &#125; </span><br><span class="line">       &#125;,</span><br><span class="line">       error: function () &#123;</span><br><span class="line">            alert(&quot;提交失败&quot;)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">public JSONObject imeiDataInsert(MultipartFile file, String note, HttpServletRequest httpServletRequest) throws IOException &#123;</span><br><span class="line">       String operator &#x3D; httpUtils.getUserEmailFromRequest(httpServletRequest);</span><br><span class="line"></span><br><span class="line">       Reader reader &#x3D; new InputStreamReader(file.getInputStream(), &quot;utf-8&quot;);</span><br><span class="line">       BufferedReader br &#x3D; new BufferedReader(reader);</span><br><span class="line">       String line;</span><br><span class="line">       boolean result &#x3D; false;</span><br><span class="line">       while ((line &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">           result &#x3D; adminBiz.imeiDataInsert(line, note);</span><br><span class="line">       &#125;</span><br><span class="line">       return httpUtils.getResponseObj(result ? ResponseCode.Success : ResponseCode.Failed)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名后端开发工程师，在日常的开发中肯定会涉及到各种各样操作IO流相关的场景，IO从字面意思表示输入输出。按照IO流不同划分的标准，可将IO流划分为以下的几种类型。
    
    </summary>
    
    
      <category term="Java基本功" scheme="https://kkcl.github.io/categories/Java%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
    
      <category term="Java" scheme="https://kkcl.github.io/tags/Java/"/>
    
      <category term="io" scheme="https://kkcl.github.io/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot文件的上传与下载</title>
    <link href="https://kkcl.github.io/springboot/springboot%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/"/>
    <id>https://kkcl.github.io/springboot/springboot%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%8A%E4%BC%A0%E4%B8%8E%E4%B8%8B%E8%BD%BD/</id>
    <published>2020-11-15T06:36:15.580Z</published>
    <updated>2020-11-15T06:57:58.719Z</updated>
    
    <content type="html"><![CDATA[<p>对于后端开发工程师而言，无论是开发什么类型的web应用，文件的上传与下载始终是两个绕不过去的技术点，针对不同的技术架构选择，可能具体实现的业务代码有所偏差，但从总体上而言，上传与下载的功能实现业务代码其实大同小异。本篇博文通过springboot的方式来实现上传与下载api。<a id="more"></a>虽然网上的相关实现代码很多，但是案例再多，如果亲自实现一遍，总感觉是空中楼阁，可望不可及。</p><h3 id="工程依赖"><a href="#工程依赖" class="headerlink" title="工程依赖"></a>工程依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file.upload.url&#x3D;C:&#x2F;Users&#x2F;CHENG&#x2F;Desktop&#x2F;upload</span><br><span class="line">file.download.url&#x3D;C:&#x2F;Users&#x2F;CHENG&#x2F;Desktop&#x2F;download</span><br><span class="line">file.delete.url&#x3D;C:&#x2F;Users&#x2F;CHENG&#x2F;Desktop&#x2F;delete</span><br><span class="line">spring.servlet.multipart.max-file-size&#x3D; 50MB</span><br><span class="line">spring.servlet.multipart.max-request-size&#x3D; 50MB</span><br></pre></td></tr></table></figure><h3 id="上传功能实现"><a href="#上传功能实现" class="headerlink" title="上传功能实现"></a>上传功能实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;file&quot;)</span><br><span class="line">public class FileController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;file.upload.url&#125;&quot;)</span><br><span class="line">    private String uploadFilePath;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;upload&quot;)</span><br><span class="line">    public String upload(@RequestParam(&quot;files&quot;)MultipartFile files[])&#123;</span><br><span class="line">        JSONObject object &#x3D; new JSONObject();</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0; i &lt; files.length; i++)&#123;</span><br><span class="line">            String fileName &#x3D; files[i].getOriginalFilename();</span><br><span class="line">            File dist &#x3D; new File(uploadFilePath + &quot;&#x2F;&quot; + fileName);</span><br><span class="line">            if(!dist.getParentFile().exists())&#123;</span><br><span class="line">                dist.getParentFile().mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line">            try&#123;</span><br><span class="line">                files[i].transferTo(dist);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line">                object.put(&quot;failure&quot;, 1);</span><br><span class="line">                object.put(&quot;result&quot;, &quot;文件上传失败！&quot;);</span><br><span class="line">                return object.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        object.put(&quot;success&quot;, 2);</span><br><span class="line">        object.put(&quot;result&quot;, &quot;上传成功！&quot;);</span><br><span class="line">        return object.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下载功能实现"><a href="#下载功能实现" class="headerlink" title="下载功能实现"></a>下载功能实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;file&quot;)</span><br><span class="line">public class FileController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;file.download.url&#125;&quot;)</span><br><span class="line">    private String downloadFilePath;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;download&quot;)</span><br><span class="line">    public String download(HttpServletResponse response,@RequestParam(&quot;fileName&quot;) String fileName)&#123;</span><br><span class="line">        File file &#x3D; new File(downloadFilePath + &quot;&#x2F;&quot; + fileName);</span><br><span class="line"></span><br><span class="line">        if(!file.exists())&#123;</span><br><span class="line">            return &quot;文件不存在&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        response.reset();</span><br><span class="line">        response.setContentType(&quot;application&#x2F;octet-stream&quot;);</span><br><span class="line">        response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">        response.setContentLength((int)file.length());</span><br><span class="line">        response.setHeader(&quot;Content-Disposition&quot;,&quot;attachement;filename&#x3D;&quot; + fileName);</span><br><span class="line"></span><br><span class="line">        try(BufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(file)))&#123;</span><br><span class="line">            byte [] buff &#x3D; new byte[1024];</span><br><span class="line">            OutputStream os &#x3D; response.getOutputStream();</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            while((i &#x3D; bis.read(buff)) !&#x3D; -1)&#123;</span><br><span class="line">                os.write(buff, 0, i);</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch (IOException e)&#123;</span><br><span class="line">            return &quot;下载失败！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;下载成功！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附带删除功能"><a href="#附带删除功能" class="headerlink" title="附带删除功能"></a>附带删除功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;file&quot;)</span><br><span class="line">public class FileController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;file.delete.url&#125;&quot;)</span><br><span class="line">    private String deleteFilePath;</span><br><span class="line"> </span><br><span class="line">    @DeleteMapping(&quot;&#x2F;delete&quot;)</span><br><span class="line">    public String deleteFile(@RequestParam(&quot;path&quot;) String path)&#123;</span><br><span class="line">        File file &#x3D; new File(deleteFilePath + &quot;&#x2F;&quot; + path);</span><br><span class="line">        if(file.isFile() &amp;&amp; file.exists())&#123;</span><br><span class="line">            file.delete();</span><br><span class="line">            return &quot;文件删除成功&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;文件删除失败！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于后端开发工程师而言，无论是开发什么类型的web应用，文件的上传与下载始终是两个绕不过去的技术点，针对不同的技术架构选择，可能具体实现的业务代码有所偏差，但从总体上而言，上传与下载的功能实现业务代码其实大同小异。本篇博文通过springboot的方式来实现上传与下载api。
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://kkcl.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://kkcl.github.io/tags/SpringBoot/"/>
    
      <category term="文件上传" scheme="https://kkcl.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="文件下载" scheme="https://kkcl.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中的拦截器和过滤器</title>
    <link href="https://kkcl.github.io/springboot/springboot%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>https://kkcl.github.io/springboot/springboot%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</id>
    <published>2020-10-25T08:54:11.276Z</published>
    <updated>2020-11-15T06:37:59.240Z</updated>
    
    <content type="html"><![CDATA[<p>一般而言，对于后端web开发人员而言，过滤器和拦截器始终是一道迈不过去的门槛，不管是在私下的个人项目练习中还是日常的开发工作中，拦截器和过滤器始终是作为一个后端开发工程师必须掌握的技术点，虽然这两个技术点非常的重要，但是由于日常的开发工作可能主要是以业务开发为主，因此很多人常常忽略这两个技术点。<a id="more"></a>甚至经常有人在面试的过程中被面试管问道相关的问题时甚至有可能三缄其口，鉴于此种情况，十分有必要彻底搞懂这两个技术点。</p><h3 id="拦截器和过滤器分别是什么"><a href="#拦截器和过滤器分别是什么" class="headerlink" title="拦截器和过滤器分别是什么"></a>拦截器和过滤器分别是什么</h3><p>其实拦截器和过滤器两者的作用在功能方面非常的类似，甚至在某些场景下所起的作用可以说是基本相同的，举个形象的例子：当我们去往某个陌生的小区时，小区的大门就是阻挡我们的第一道门槛，进去小区之后如果想要进入某具体的楼层时，则需要有对应楼层的门禁卡，这个例子中过滤器就充当了小区大门的角色，而拦截器则起着具体楼层门禁卡的作用。一般而言当发起一次请求时，最先经过过滤器处理，然而在经过相应的拦截器处理。</p><h3 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h3><ul><li>Filter依赖Servlet容器，属于Servlet容器规范的一部分，而拦截器是单独存在的，可以在任何情况下使用。</li><li>Filter的执行由Servlet容器完成，而拦截器主要通过动态代理的方式执行</li><li>Filter的生命周期由Servlet容器管理，而拦截器则可以通过IOC容器进行处理，可以通过注入等方式来获取相对应的Bean的实例，相对于过滤器更方便。</li></ul><h3 id="拦截器和过滤器的实现方式"><a href="#拦截器和过滤器的实现方式" class="headerlink" title="拦截器和过滤器的实现方式"></a>拦截器和过滤器的实现方式</h3><p>拦截器的实现方式：实现HandlerInterceptor接口重写相关的方法，并将该拦截器以组件的方式配置成配置类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class LogInterceptor implements HandlerInterceptor &#123;</span><br><span class="line">    long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">     Object handler) throws Exception &#123;</span><br><span class="line">        start &#x3D; System.currentTimeMillis();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, </span><br><span class="line">    bject handler, ModelAndView modelAndView) throws Exception &#123;</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;拦截器消耗的总时间是：&quot; + (end - start) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, </span><br><span class="line">    Object handler, Exception ex) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class InterceptorConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">        registry.addInterceptor(new LogInterceptor()).addPathPatterns(&quot;&#x2F;**&quot;);</span><br><span class="line">        super.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过滤器的实现方式：实现Filter接口，并将过滤器以组件的方式配置成Bean类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class LogFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, </span><br><span class="line">    FilterChain filterChain) throws IOException, ServletException &#123;</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line">        filterChain.doFilter(servletRequest,servletResponse);</span><br><span class="line">        long end &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;过滤器消耗的时间总计是：&quot; + (end - start) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class FilterConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean registerFilter()&#123;</span><br><span class="line">        FilterRegistrationBean registrationBean &#x3D; new FilterRegistrationBean();</span><br><span class="line">        registrationBean.setFilter(new LogFilter());</span><br><span class="line">        registrationBean.addUrlPatterns(&quot;&#x2F;*&quot;);</span><br><span class="line">        registrationBean.setName(&quot;LogFilter&quot;);</span><br><span class="line">        registrationBean.setOrder(1);</span><br><span class="line">        return registrationBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拦截器和过滤器的运用场景"><a href="#拦截器和过滤器的运用场景" class="headerlink" title="拦截器和过滤器的运用场景"></a>拦截器和过滤器的运用场景</h3><ul><li>日志记录</li><li>权限检查</li><li>性能监控</li><li>通用行为</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般而言，对于后端web开发人员而言，过滤器和拦截器始终是一道迈不过去的门槛，不管是在私下的个人项目练习中还是日常的开发工作中，拦截器和过滤器始终是作为一个后端开发工程师必须掌握的技术点，虽然这两个技术点非常的重要，但是由于日常的开发工作可能主要是以业务开发为主，因此很多人常常忽略这两个技术点。
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://kkcl.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://kkcl.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>2020，路在何方？</title>
    <link href="https://kkcl.github.io/wechat/2020%EF%BC%8C%E8%B7%AF%E5%9C%A8%E4%BD%95%E6%96%B9/"/>
    <id>https://kkcl.github.io/wechat/2020%EF%BC%8C%E8%B7%AF%E5%9C%A8%E4%BD%95%E6%96%B9/</id>
    <published>2020-04-15T04:07:59.513Z</published>
    <updated>2020-04-15T04:14:38.667Z</updated>
    
    <content type="html"><![CDATA[<p>将时间拨回两年前，回到那个纸短情长闷热的夏季，那时相信应该没有多少人会对未来的前景持悲观态度。那个夏天没有焦躁、也没有无奈、更没有彷徨 ，有的只是青春的激情、躁动、向往，然而一场疫情的到来，却让一切全部发生了骤变，化为了泡影。<a id="more"></a></p><p>从目前的情况来看，无论是从企业发布的招聘需求数量还是从求职的人数来看，两边都呈现出极端化。一方面企业为了在这次疫情中尽最大的可能保住公司的现金流，不是采取裁员的措施，就是不断的降低企业内部员工的薪资，有的企业把这样的行为称之为共度难关。</p><p>从他们给员工灌输的思想来看，一旦企业无法存活下去，员工的日子也好不到哪里去，与其到时候公司倒闭破产所有人被迫到处求职，还不如这个时候无条件的听从领导的安排，自觉、主动的接受公司的降薪要求。</p><p>另一方面因为各大公司不约而同的进行裁员、降薪等手段，造成现在的就业市场上存在着很大一批的求职者，有些人待业的时间甚至超过半年之久，在这样的情形下，非常有可能其中的一些人宁愿采取降薪的形式来入职那些他们原本就看不上的企业。</p><p>类似于田忌赛马的机制，一旦那些具有高竞争力的人愿意降薪入职那些低一阶的职位，往往意味着那些原先能力只适合这些职位的人会失去这一类的职位，这样的逻辑层层叠加，到最后总会有一些技能条件不如其他求职者的人会失去工作，最后为了生存不得不从事一些他们之前自以为绝对不可能从事的职业，比如目前已经屡见不鲜的程序员群体转行送外卖、开滴滴等。不是看不起这些职业，单纯的从个人的角度来看，只要是能够为这个社会创造价值，都应当得到他们应该拥有的尊重。</p><p>从这些已经发生的现实情况观察，我们不难得出今年的这个求职市场，已经的确相对于往年冷清了好多。越是这样的时候，作为普通个体的我们就越应该好好的思考下接下来的路我们应该怎样走。</p><p>不是不看好未来的经济发展的前景，从长远的经济大趋势来看，就像国家有关政府机构预测的那样，未来至少10年的时间内，经济长期稳定向好的大盘并没有发生什么本质上的改变，也就是说稳定增长的基本盘不可能发生什么大的动摇。在这样的情况下，普通群体进行阶级跃进、实现财富自由的机会仍然存在，只不过相比之前的十年可能更加的辛苦些。</p><p>另外从大的方面出发来看，受益于高等教育持续的大规模扩招，越往后，文凭的价值会缩水的更加厉害。反映在职场的现实中非常有可能出现某些企业的招聘需求不断提升的过程，未来某些企业的招聘岗位学历要求十分有可能从硕士学历开始要求起步，不说这样的要求是否合理，一旦这样的事情发生，基本上也就宣告了学历制度的正式死亡，到那时真的可能出现如同马云所言“你花费大量学费取得的学历文聘，很有可能只是一份你向学校缴纳学费的凭证”。</p><p>到那时在大的社会背景下，那些依靠学历背景背书，本身没有什么强大的竞争力的人很可能面临着出局的风险。同样也不是说学历不重要，仅仅从一个入职职场数载的职场老鸟的角度来看，越往后学历不仅对于普通人十分的重要，反而可以说是至关重要，但学历也只能确保你投递意向岗位的时候保证你拥有一个面试的机会，至于后续的结果怎么样，还得凭借自己的个人实力。就像有些地区的农村人常讲的一句话，我为什么非要有个儿子，这玩意就像原子弹一样，虽然有可能一辈子用不上，但是不能没有。</p><p>职场大环境已然如此，作为普通的个体最好做到未雨绸缪。特别是像今年一样，迫于疫情的压力，有的公司干脆直接不发或者少发工资，在这样的情况下，很多人的收入来源也基本上断了，可是各种贷款支出费用还是需要偿还的啊。越往后，遭遇这样的日子的概率可能会更加的频繁，作为个人最好还是尽量的拓宽自己的收入来源渠道，要不然要是哪天人到中年面临上有老、下有小的窘迫境地，真不知该如何处理。</p><p>在此还是建议大部分上班族在2020年开始着手准备一两份自己的副业，确保在主业收入断掉之后还有副业来做暂时性的支撑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将时间拨回两年前，回到那个纸短情长闷热的夏季，那时相信应该没有多少人会对未来的前景持悲观态度。那个夏天没有焦躁、也没有无奈、更没有彷徨 ，有的只是青春的激情、躁动、向往，然而一场疫情的到来，却让一切全部发生了骤变，化为了泡影。
    
    </summary>
    
    
      <category term="公众号文章" scheme="https://kkcl.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="wechat" scheme="https://kkcl.github.io/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>2020，我们都是见证历史的人！</title>
    <link href="https://kkcl.github.io/wechat/2020%EF%BC%8C%E6%88%91%E4%BB%AC%E9%83%BD%E6%98%AF%E8%A7%81%E8%AF%81%E5%8E%86%E5%8F%B2%E7%9A%84%E4%BA%BA/"/>
    <id>https://kkcl.github.io/wechat/2020%EF%BC%8C%E6%88%91%E4%BB%AC%E9%83%BD%E6%98%AF%E8%A7%81%E8%AF%81%E5%8E%86%E5%8F%B2%E7%9A%84%E4%BA%BA/</id>
    <published>2020-04-11T07:59:52.343Z</published>
    <updated>2020-04-13T03:51:25.317Z</updated>
    
    <content type="html"><![CDATA[<p>2020年注定是一个不平凡的年份，而身处这个时代的我们，每一个人都是历史的见证者、亲历者、参与者。不管你承不承认，裹挟于时代的洪流之中，每一天、每一刻我们都被历史的车轮推着走的，而每一道车轮轨迹的背后，都是一串串历史的印记，而2020年历史车轮遗留下的这串印记，必将注定特别的与众不同。</p><a id="more"></a><p>自新型冠状病毒发生以来，为了在最大限度上阻断病毒在人群中的传播途径，全国上下不约而同的采取了非常严厉的防控措施，即使是到今天，在一些重点地区这样的管控措施依然没有放松的迹象。虽然单就目前全国的情况来看，病毒的传播趋势已经被阻断了，但在一些地区，还存在着少量的无症状感染者，这些携带病毒的存量人员一天不清除干净，全国上下一天就得不到安宁，在这样的情形下，莫说允许一部分公司先行进行复工，就是能不能恢复到以前那样的生活状态还是个重大的问题。</p><p>按照往年的惯例，再过两个多月的时间，就应该迎来了一年一度的高考时间，可今年由于疫情的缘故，一些地区即使是到今天也未能进行正常的复课，虽然说可以采取网上直播教学的方法，但这种方式究其本质上而言并不适合大规模的推广。首先我们不得不承认的一个现实情况是：在我们这个社会中确实是存在贫富差距的，一些在我们看来非常稀松平常的事情，在一些特殊的家庭可能即使拼尽全力也未尝能够实现。</p><p>直播方式虽然方便，但同时也要求上课的学生群体必须具备有网、有智能设备的条件，在一些贫困的学生家庭，别说具备接入网络的条件，就是能不能有一部能够接入网络的智能手机还是个问题，要不然国家有关部门也不会明令在此期间严格禁止教师直播上课或录课。究其根本还是考虑到一个教育的公平问题。</p><p>如果按照往些年的情况部署，高考应该是定于每年的6月7号到8号，可今年由于疫情的原因满打满算只剩两个多月时间，长时间脱离课堂的情况下，不要说学生能否保持原先的学习状态积极的备战高考，就是有这样的心思，也估计很难确保有一个适合的学习的环境。同时由于不同家庭父母之间所受教育的差异，在这段时间内可能对待孩子的管理态度也不尽相同，这也在一定程度上造成了教育的不公平性。可能也是考虑到这种实际情况，在经过慎重的考虑后党中央、国务院还是做出了高考延期一个月的决定。</p><p>这个决定一经媒体播出，已然成为了一个全民关注的历史事件，要知道即使是在非典肆虐的2003年，高考也没有向今年一样推迟过，从这个角度来看，2020年我们见证的第一个历史就是延迟高考。</p><p>那么高考的延迟对于我们普通人而言又意味着什么呢？首先非常重要的一点就是不管未来疫情到底在何时结束，线上教育一定会迎来一大波红利发展期，线下的传统授课方式也可能迎来巨大的冲击，一些传统的教育巨头如新东方、好未来等必将加快向线上转移的速度，与此同时一些具有真才实学的个体也能收获一大波线上的教育红利。围绕着这个战场，可能又将迎来一波血腥的厮杀。</p><p>到今天为止，美国的确诊病例已经超过40w，这还是已经确诊的病例的数量，未确诊的人数还不知道有多少，如果按照目前的这个人数增加的速度来看，相信要不了多长时间，美国的确诊人数应该会超过50w。</p><p>在此之前，美国的股市已经发生过几次熔断事件，要知道美国股市在过去的几十年中也只不过发生过一次熔断，而这回由于新冠疫情的原因，不到一年的时间就接二连三的发生几次股市熔断的情况了，这也从侧面说明当今的全球资本并不相信特朗普政府能够有能力控制住这场疫情，基于这样的推测，大量的资金可能会在今年内从美国股市抽身离场，美国万股齐跌的状况还暂时不能确定到底什么时候到头。但资本自身拥有的对资本繁殖的狂热追求，相信只要从美国股市抽身，在很大程度上会来到资本更安全、回报率更高的中国市场。估计下半年，中国股市会迎来大量的全球资本热钱的涌入，只要美国的疫情一天得不到控制，资本就一天不会离开中国。</p><p>与美国的情况恰恰相反，虽然疫情“首先”在我国发现，但截至到目前，全国上下已经基本上控制住了这场疫情，虽然目前还没有彻底的消灭掉病毒，但与美国这种大爆发的情况相比还是比较乐观的，按照国内有关专家的说法，即使有些地区存在一定数量的未确诊病例，相信在现在的严格防控的措施面前，也绝对不会再出现武汉地区那种大范围的爆发情况出现。</p><p>基于目前欧美国家已经成为此次疫情爆发的重灾区，相信在未来的半年内，欧美国家基本不可能恢复到以往的那种正常的生产状态下，除非他们不怕牺牲，搞大规模的群体免疫政策，一旦这样的措施以立法的形式执行，不仅对中国、对全世界各个国家的人民来说都是一场灾难。从个人的角度来看，无论说作为普通的老百姓群体，还是稍微有点智商的政治家都不太可能执行这样的政策。</p><p>所以，这些国家都先后不约而同的采取了封国的措施，给全球的经济造成了很大的不确定性。</p><p>今年，无论是从宏观的角度还是从微观的角度来看，对个人和企业都是一道生死存亡的考验。企业要生存、员工要工资，国家要完成年前制定的一系列gdp目标，如果还不采取有效的经济刺激政策，估计今年相关的经济数据应该不会太好看。基于这样的猜测，在此大胆的预测几年过后向2008年的金融危机一样，两到三年的时间，肯定又会出现2010年以后那样对经济产生翻天覆地影响的移动互联网那样的爆发潮，对于我们这样的普通个体而言，往往这样的时刻就会成为我们改变自身命运的重要转机窗口，抓住了不仅顺利晋级上一个阶层实现财富自由，抓不住又不知道这样的机会又会在未来的哪一个时刻出现。</p><p>从我们国家目前的发展情况来看，工业化、城镇化已经基本上进入了中后期，属于普通人的机会也越来越稀少，如果再不好好抓住最后的黄金十年，普通人有可能再无出头之日。至于我们的国家的前途命运，如果还按照总设计师规划的路径那样一步一个脚印那样走，相信只需要不到20年的时间，我们肯定能够迎来伟大复兴的高光时刻。</p><p>2020年，不仅对企业，对个人同样至关重要，毕竟我们可都是见证历史的人！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年注定是一个不平凡的年份，而身处这个时代的我们，每一个人都是历史的见证者、亲历者、参与者。不管你承不承认，裹挟于时代的洪流之中，每一天、每一刻我们都被历史的车轮推着走的，而每一道车轮轨迹的背后，都是一串串历史的印记，而2020年历史车轮遗留下的这串印记，必将注定特别的与众不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="公众号文章" scheme="https://kkcl.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="wechat" scheme="https://kkcl.github.io/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>武汉物理解封容易，人心解封却很难！</title>
    <link href="https://kkcl.github.io/wechat/%E6%AD%A6%E6%B1%89%E7%89%A9%E7%90%86%E8%A7%A3%E5%B0%81%E5%AE%B9%E6%98%93,%E4%BA%BA%E5%BF%83%E8%A7%A3%E5%B0%81%E5%8D%B4%E5%BE%88%E9%9A%BE/"/>
    <id>https://kkcl.github.io/wechat/%E6%AD%A6%E6%B1%89%E7%89%A9%E7%90%86%E8%A7%A3%E5%B0%81%E5%AE%B9%E6%98%93,%E4%BA%BA%E5%BF%83%E8%A7%A3%E5%B0%81%E5%8D%B4%E5%BE%88%E9%9A%BE/</id>
    <published>2020-04-08T14:42:52.384Z</published>
    <updated>2020-04-10T07:18:12.935Z</updated>
    
    <content type="html"><![CDATA[<p>​今天是2020年4月8日，历史将会铭记这个特殊的日子。经过整整76天漫长的等待之后，湖北省武汉市终于打开了尘封许久的通道大门，这意味着从今天开始，整个湖北省都将有序放开省内省外人员流动限制，从这这点而言，以湖北为重灾区的疫情主战场已经取得了重大的胜利，真正达到了总书记所强调的武汉胜则湖北胜，湖北胜则全国胜的要求。然而有时候物理上的解封还相对容易，可如何消除湖北省以外，各地居民心底上的枷锁、戒备却还是个值得研究的重要命题。</p><a id="more"></a><p>自疫情发生以来，全国各地共选派330多支医疗队，超过4万名医务人员驰援湖北。其中，重症医学科、感染科、呼吸科、循环内科的专业人员就达到了16000多人。可以说，这样的规模、这样的力度在共和国的历史上还是屈指可数的。为了战胜这场疫情，可以说全国除湖北以外的各省市几乎是把自家的医疗精英家底尽数都暂时性的搬去了湖北省，在这样的支援力度下，同时加上英雄的城市、英雄的人民的鼎力配合，这场战役从某种程度上来说结局注定是美好的，事实也的确如此。</p><p>疫情初期，为了有效的缓解人等床的现实情况，国家有关部门负责同志火速商谈，最终决定借鉴北京小汤山医院模式，立即开建新的收治医院，于是在10天之内雷神山、火神山相继拔地而起，再一次重新向世人刷新了中国速度。根据事后有关人士采访的资料得知，为了支援雷神山、火神山医院的建设，从全国各地赶来的建筑工人在最高峰的时候一度超过5000人同时在工地上进行昼夜不停的施工，有的建筑工人甚至一连好几天都奋战在建设的工地上，一刻也没有合过眼，只为了早日能把这两座能救命的医院建设好投入使用。这些人同样也应该像那些支援武汉疫情抗战的医生、护士一样，得到应该有的荣誉，他们同样也是我们这个时代的英雄。</p><p>如今两个多月的时间已经过去，当初紧急筹建用来收治病人的雷神山、火神山医院也完成了属于他们的历史使命，关门封舱。湖北地区更是从累计确诊人数8万多人下降到现在医院治疗人数不足1000人，估计在不远的未来，能够实现治疗人数彻底清零。在这场无声的战役中，湖北省内的全体居民为了战役的胜利付出了很多，但他们却远远没有没有得到该有的尊重。</p><p>目前，虽然湖北地区已经解除了离汉离鄂通道，许多人也趁这段时间赶紧外出打工就业，争取把这段时间失去的损失弥补回来，但现实的情况却不是非常的理想，一些地区不是明令要求湖北籍的员工不得未经请示就返回，就是要求进行两周的隔离，这些措施虽然是合理的，但就一些失去收入已经两个多月的湖北人而言，每天几百块的隔离费用已经在无形中打退了许多人的务工念想，在这些人的眼中，与其白白的花费几千元的隔离费用，还不如继续呆在家里等待下一步的通知。</p><p>其实跟这些小事相比，现在湖北人最难以忍受的就是只要出省务工，在许多外省人的眼里，自己不仅得不到他们中有些人的一丝丝同情，反而成为了他们眼中的灾星，更有甚者唯恐避之不及，彷佛疫情之后的湖北人成了众矢之的。</p><p>有些湖北人本来打算返京复工，可当填完必要的申报材料之后，还未被审批放行，千里之外的歧视早已经随着5G的网络飞速而来。有些合租的湖北人，刚询问合租室友是否能够居家隔离，下一秒就有人直接背地里打电话给房东，威吓到：只要这个湖北籍的合租室友返回出租房，自己立马要求退租，不知面对这样的场景时，作为一个湖北籍的租客作何感想。</p><p>疫情还没有结束的时候，你们嘴里一个个喊着武汉加油、湖北加油、中国加油，可当疫情真的差不多快结束时，湖北人好不容易从封闭的环境中走出来，其中的一些人迎接他们的不是欢迎，也不是鼓励，却是恶狠狠的歧视。这一刻不知湖北人该是伤心还是寒心。</p><p>湖北物理上的道路封锁虽然已经解开，部分人心底对湖北人的枷锁、歧视却远远没有一丝丝松开的迹象。如果此刻你的身边有湖北省，那么请你从你做起，公平善待每一个遭遇过苦难的湖北人吧，病毒虽无情，但我坚信人家却有爱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​今天是2020年4月8日，历史将会铭记这个特殊的日子。经过整整76天漫长的等待之后，湖北省武汉市终于打开了尘封许久的通道大门，这意味着从今天开始，整个湖北省都将有序放开省内省外人员流动限制，从这这点而言，以湖北为重灾区的疫情主战场已经取得了重大的胜利，真正达到了总书记所强调的武汉胜则湖北胜，湖北胜则全国胜的要求。然而有时候物理上的解封还相对容易，可如何消除湖北省以外，各地居民心底上的枷锁、戒备却还是个值得研究的重要命题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="公众号文章" scheme="https://kkcl.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="wechat" scheme="https://kkcl.github.io/tags/wechat/"/>
    
  </entry>
  
</feed>
