<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小白混职场</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kkcl.github.io/"/>
  <updated>2020-06-21T14:49:05.417Z</updated>
  <id>https://kkcl.github.io/</id>
  
  <author>
    <name>小白混职场</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot入门案例</title>
    <link href="https://kkcl.github.io/springboot/springboot%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B01/"/>
    <id>https://kkcl.github.io/springboot/springboot%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B01/</id>
    <published>2020-06-21T14:35:25.546Z</published>
    <updated>2020-06-21T14:49:05.417Z</updated>
    
    <content type="html"><![CDATA[<p>虽说springboot已经在Java领域已经火了好几年的时间了，现在网络上关于这个技术的相关教程也是非常的多，但是从另一个角度出发来看不管网上的相关资料如何的丰富总归是人家写的，与其如此还不如自己从头开始将一些常用的基础技术总结以下，这篇博文主要简单的介绍springboot的入门案例。</p><hr><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽说springboot已经在Java领域已经火了好几年的时间了，现在网络上关于这个技术的相关教程也是非常的多，但是从另一个角度出发来看不管网上的相关资料如何的丰富总归是人家写的，与其如此还不如自己从头开始将一些常用的基础技术总结以下，这篇博文主要简单的介绍springbo
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://kkcl.github.io/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="https://kkcl.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud高频面试题</title>
    <link href="https://kkcl.github.io/SpringCloud%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/SpringCloud%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-26T07:20:43.588Z</published>
    <updated>2020-04-26T07:21:30.375Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="SpringCloud" scheme="https://kkcl.github.io/categories/SpringCloud/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="SpringCloud" scheme="https://kkcl.github.io/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot高频面试题</title>
    <link href="https://kkcl.github.io/SpringBoot%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/SpringBoot%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-26T07:19:50.945Z</published>
    <updated>2020-04-26T07:22:02.397Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="SpringBoot" scheme="https://kkcl.github.io/categories/SpringBoot/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="SpringBoot" scheme="https://kkcl.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring高频面试题</title>
    <link href="https://kkcl.github.io/Spring%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/Spring%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-26T07:19:04.279Z</published>
    <updated>2020-05-27T10:30:30.063Z</updated>
    
    <content type="html"><![CDATA[<p>不管是在平常的工作中还是日常的求职面试中，Spring相关的问题总是一道迈不过去的坎，不仅是因为Spring框架的完美性，更多的还是因为对于绝大部分公司的程序员群体而言，平常的开发工作基本上离不开Spring框架，那么自然面试中肯定也少不相关的问题，与其每次都让面试管问的哑口无言，还不如从现在开始总结相关的Spring面试题，等到面试的时候变被动为主动，直接打面试管一个措手不及。</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不管是在平常的工作中还是日常的求职面试中，Spring相关的问题总是一道迈不过去的坎，不仅是因为Spring框架的完美性，更多的还是因为对于绝大部分公司的程序员群体而言，平常的开发工作基本上离不开Spring框架，那么自然面试中肯定也少不相关的问题，与其每次都让面试管问的哑
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://kkcl.github.io/categories/Spring/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Spring" scheme="https://kkcl.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Redis高频面试题</title>
    <link href="https://kkcl.github.io/Redis%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/Redis%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-26T07:18:13.562Z</published>
    <updated>2020-04-27T04:11:29.392Z</updated>
    
    <content type="html"><![CDATA[<p>Redis作为开发人员必会的开发技术，无论是在日常的工作中，还是在各大招聘公司的技术面试过程中，始终也是一道不能跨越过去的坎，与其每次被技术面试管问的哑口无言，还不如趁平时有空的时候全面的总结下这些问题，也可以说是常规的面试套路。彻底的告别面试过程中来自面试官的灵魂拷问。<a id="more"></a>虽然大部分面试者从内心的深处是排斥这种技术面试的，但是无论是从公司的角度还是从候选人的角度来看，总不能面试的过程中还全程的与面试官聊crud吧，这样的话估计全程只能尬聊了。还是一句话，就像部分农村地区将男孩比作核弹的例子一样，即使不用但是不能确保没有。</p><hr><ul><li>什么是Redis<br>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。目前，Vmware在资助着redis项目的开发和维护。</li><li>Redis与Memcached的区别与比较<br>1、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。<br>2、Redis支持数据的备份，即master-slave模式的数据备份。<br>3、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。<br>4、redis的速度比memcached快很多<br>5、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</li><li>使用redis有哪些好处<br>1、 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)。<br>2、支持丰富数据类型，支持string，list，set，sorted set，hash<br>3、 支持事务 ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。<br>4、丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除。</li><li>Redis常用数据类型的引用场景<br>1、String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用； 常规计数：微博数，粉丝数等。<br>2、Hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。<br>3、list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，最新消息排行等功能都可以用Redis的list结构来实现。<br>4、set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。<br>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同喜好、二度好友等功能。<br>5、和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。<br>举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用Redis中的SortedSet结构进行存储。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis作为开发人员必会的开发技术，无论是在日常的工作中，还是在各大招聘公司的技术面试过程中，始终也是一道不能跨越过去的坎，与其每次被技术面试管问的哑口无言，还不如趁平时有空的时候全面的总结下这些问题，也可以说是常规的面试套路。彻底的告别面试过程中来自面试官的灵魂拷问。
    
    </summary>
    
    
      <category term="Redis" scheme="https://kkcl.github.io/categories/Redis/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Redis" scheme="https://kkcl.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper高频面试题</title>
    <link href="https://kkcl.github.io/Zookeeper%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/Zookeeper%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-26T07:17:10.076Z</published>
    <updated>2020-05-17T10:14:30.623Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Zookeeper" scheme="https://kkcl.github.io/categories/Zookeeper/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Zookeeper" scheme="https://kkcl.github.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo高频面试题</title>
    <link href="https://kkcl.github.io/Dubbo%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/Dubbo%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-26T07:16:08.073Z</published>
    <updated>2020-04-26T12:36:58.295Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名软件开发工程师，特别是以Java作为主力开发语言的开发人员来说，分布式相关的问题始终是一道迈不过去的坎，无论是大公司还是中小型公司，不管什么级别的面试，好像总也少不了相关的问题，而dubbo作为分布式开源软件的优秀代表，加上又是阿里巴巴开源的，自然首当其冲的被运用到各大中小型互联网公司的实际生产中去。<a id="more"></a>也正是因为如此，面试过程中dubbo总是一道迈不过去的坎，与其如此还不入早点一网扫净相关的问题。</p><hr><ul><li>Dubbo是什么？<br>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC 分布式服务框架，现已成为 Apache 基金会孵化项目。</li><li>为什么要用Dubbo？<br>因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了 Netty、Zookeeper，保证了高性能高可用性。使用Dubbo可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。</li><li>Dubbo和Spring Cloud有什么区别？<br>通信方式不同,Dubbo 使用的是 RPC 通信，而Spring Cloud使用的是HTTP RESTFul方式;组成部分不同组件,dubbo组件有</li><li>Dubbo内置了哪几种服务容器<br>Spring Container、Jetty Container、Log4j Container。</li><li>Dubbo里面有哪几种节点角色<br>暴露服务的服务提供方Provider,调用远程服务的服务消费方Consumer,服务注册与发现的注册中心Registry,统计服务的调用次数和调用时间的监控中心Monitor,服务运行容器Container。</li><li>Dubbo默认使用什么注册中心，还有别的选择吗<br>推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。</li><li>Dubbo有哪几种配置方式？<br>Spring 配置方式、Java API 配置方式。</li><li>在 Provider 上可以配置的 Consumer 端的属性有哪些<br>timeout：方法调用超时、 retries：失败重试次数，默认重试 2 次、loadbalance：负载均衡算法，默认随机、actives 消费者端，最大并发调用限制。</li><li>Dubbo启动时如果依赖的服务不可用会怎样？<br>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=”true”，可以通过 check=”false” 关闭检查。</li><li>Dubbo推荐使用什么序列化框架，你知道的还有哪些<br>推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。</li><li>Dubbo有哪几种负载均衡策略，默认是哪种<br>随机(默认)、轮询、最少活跃调用数，相同活跃数的随机,一致性 Hash，相同参数的请求总是发到同一提供者。</li><li>当一个服务接口有多种实现时怎么做<br>当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。</li><li>服务上线怎么兼容旧版本<br>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</li><li>Dubbo可以对结果进行缓存吗<br>可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。</li><li>Dubbo的管理控制台能做什么<br>管理控制台主要包含：路由规则，动态配置，服务降级，访问控制，权重调整，负载均衡，等管理功能。</li><li>你觉得用Dubbo好还是Spring Cloud好<br>扩展性的问题，没有好坏，只有适合不适合，不过我好像更倾向于使用Dubbo, Spring Cloud版本升级太快，组件更新替换太频繁，配置太繁琐。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名软件开发工程师，特别是以Java作为主力开发语言的开发人员来说，分布式相关的问题始终是一道迈不过去的坎，无论是大公司还是中小型公司，不管什么级别的面试，好像总也少不了相关的问题，而dubbo作为分布式开源软件的优秀代表，加上又是阿里巴巴开源的，自然首当其冲的被运用到各大中小型互联网公司的实际生产中去。
    
    </summary>
    
    
      <category term="Dubbo" scheme="https://kkcl.github.io/categories/Dubbo/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Dubbo" scheme="https://kkcl.github.io/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Java高频面试题</title>
    <link href="https://kkcl.github.io/Java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/Java%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-24T09:44:15.480Z</published>
    <updated>2020-05-04T08:16:59.401Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名后端开发人员，主力的编程语言为Java,因为前些年随着移动互联网的快速发展，造成非常大的需求空缺，在这样的情形下，有非常多的不同行业的人通过培训等各种各样的方式强行进入这个行业，造成现在的就业市场上存在着大量的培训结构出来的人员，同时又因为互联网红利的见顶，需求端已经基本饱和，短期内各大公司不会在像以前一样大量的招聘相关人才。<a id="more"></a>如果没有出现大的技术变革，这个行业基本上已经是一种存量竞争的态势，越是这样的时候，个人自生的素质成为是否能够抵御风险的重要砝码。鉴于目前的这种实际情况，有必要彻底的搞明白Java面试过程中一些常见的问题。</p><hr><ul><li>JDK、JRE、JVM 分别是什么关系？<br>1、JDK 即为Java开发工具包，包含编写Java程序所必须的编译、运行等开发工具以及 JRE。开发工具如：用于编译Java程序的javac命令、用于启动JVM运行Java程序的 Java命令、用于生成文档的Javadoc命令以及用于打包的jar命令等等。<br>2、JRE即为Java运行环境，提供了运行Java应用程序所必须的软件环境，包含有Java虚拟机（JVM）和丰富的系统类库。系统类库即为Java提前封装好的功能类，只需拿来直接使用即可，可以大大的提高开发效率。<br>3、JVM 即为Java虚拟机，提供了字节码文件（.class）的运行环境支持。 简单说，就是JDK包含JRE包含JVM。</li><li>什么是 Java 虚拟机（JVM）？为什么 Java 被称作是“平台无关的编程语言”？<br>Java 虚拟机是一个可以执行 Java 字节码的虚拟机进程。Java 源文件被编译成能被 Java 虚拟机执行的字节码文件。<br>Java 被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java 虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</li><li>Java中实现多态的机制<br>多态是面向对象的一个基本特征。java中的多态是指父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。</li><li>抽象类与接口的区别<br>1、抽象类可以有构造方法，接口中不能有构造方法。<br>2、抽象类中可以有普通成员变量，接口中没有普通成员变量<br>3、抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法<br>4、抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然<br>eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。<br>5、抽象类中可以包含静态方法，接口中不能包含静态方法。<br>6、抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是publicstatic final类型，并且默认即为publicstatic final类型。<br>7、一个类可以实现多个接口，但只能继承一个抽象类。</li><li>String和StringBuilder、StringBuffer的区别？<br>Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引的字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被 synchronized 修饰，因此它的效率也比 StringBuffer 要高。</li><li>HashMap和HashTable有什么区别<br>1、HashMap 是非线程安全的，HashTable 是线程安全的。<br>2、HashMap 的键和值都允许有 null 值存在，而 HashTable 则不行。<br>3、因为线程安全的问题，HashMap 效率比 HashTable 的要高。<br>4、HashTable 是同步的，而 HashMap 不是。因此，HashMap 更适合于单线程环境，而 HashTable 适合于多线程环境。</li><li>Object有哪些公用方法<br>1、clone 保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。<br>2、equals 在Object中与==是一样的，子类一般需要重写该方法。<br>3、hashCode 该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</li><li>BIO、NIO、AIO 有什么区别？<br>1、BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。<br>2、NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。<br>3、AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li><li>谈谈对volatile关键字的理解<br>volatile是由java虚拟机提供的轻量级的同步机制，保证可见性、不保证原子性、禁止指令重排</li><li>红黑树的理解<br>1、每个节点非红即黑<br>2、根节点总是黑色的<br>3、如果节点是红色的，则它的子节点必须是黑色的（反之不一定）<br>4、每个叶子节点都是黑色的空节点（NIL节点）<br>5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名后端开发人员，主力的编程语言为Java,因为前些年随着移动互联网的快速发展，造成非常大的需求空缺，在这样的情形下，有非常多的不同行业的人通过培训等各种各样的方式强行进入这个行业，造成现在的就业市场上存在着大量的培训结构出来的人员，同时又因为互联网红利的见顶，需求端已经基本饱和，短期内各大公司不会在像以前一样大量的招聘相关人才。
    
    </summary>
    
    
      <category term="Java" scheme="https://kkcl.github.io/categories/Java/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Java" scheme="https://kkcl.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JVM高频面试题</title>
    <link href="https://kkcl.github.io/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/JVM%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-24T09:43:07.204Z</published>
    <updated>2020-04-24T09:44:03.889Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JVM" scheme="https://kkcl.github.io/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://kkcl.github.io/tags/JVM/"/>
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>应知应会的设计模式</title>
    <link href="https://kkcl.github.io/%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://kkcl.github.io/%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-24T06:48:44.791Z</published>
    <updated>2020-05-17T04:14:29.333Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式虽说非常的重要，但是针对大部分的开发人员的工作现状而言，在他们日常的工作中是根本不可能用到这些的，即便如此，但是作为一名开发人员这些东西迟早是需要掌握的，除非你没打算在这个行业深耕或者只愿意长时间的充当公司的咸鱼，如果是这样的情况，这些东西确实不需要深入的掌握。<a id="more"></a>但是考虑到目前的现实，越往后估计软件开发这个行业对于从业者的要求可能会越高，因此在一个未来可预见的存量竞争的战场，多掌握一些必要的设计模式无疑是增加个人竞争力的重大举措。</p><hr><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><blockquote><p>目前已经成型的设计模式一共有23种，可大致划分为三大类：创建型、结构性、行为型，其中面试中常考的有：工厂模式、单例模式、观察者模式、代理模式、原型模式<br>1、创建型：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。<br>2、结构型：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式<br>3、行为型：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式虽说非常的重要，但是针对大部分的开发人员的工作现状而言，在他们日常的工作中是根本不可能用到这些的，即便如此，但是作为一名开发人员这些东西迟早是需要掌握的，除非你没打算在这个行业深耕或者只愿意长时间的充当公司的咸鱼，如果是这样的情况，这些东西确实不需要深入的掌握。
    
    </summary>
    
    
      <category term="设计模式" scheme="https://kkcl.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://kkcl.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL高频面试题</title>
    <link href="https://kkcl.github.io/MySQL%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/MySQL%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-24T06:33:13.981Z</published>
    <updated>2020-04-29T10:15:03.101Z</updated>
    
    <content type="html"><![CDATA[<p>不管是IT什么领域的开发人员，肯定都要求会一些数据库相关的知识，尤其是后端的开发人员，不仅要求掌握数据库相关的理论知识，还要求拥有很多的实际开发经验，通常而言MySQL已经成为软件开发领域的扛把子，因此这篇文章的相关知识也是从MySQL相关的知识而展开的。<a id="more"></a>至于其他的数据库相关的知识，从理论上讲应该大同小异，无外乎基本语法方面可能稍有差异。</p><hr><h3 id="MySQL常见的理论问题"><a href="#MySQL常见的理论问题" class="headerlink" title="MySQL常见的理论问题"></a>MySQL常见的理论问题</h3><ul><li>主键、超键、候选键、外键的认识<br>1、主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。<br>2、超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。<br>3、候选键：是最小超键，即没有冗余元素的超键。<br>4、外键：在一个表中存在的另一个表的主键称此表的外键。</li><li>数据库事务的四个特性及含义<br>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。<br>1、原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>2、一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。<br>3、隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。<br>4、持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li><li>drop,delete与truncate的区别<br>1、drop直接删掉表;truncate删除表中数据，再插入时自增长id又从1开始;delete删除表中数据，可以加where字句。<br>2、DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。<br>3、表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。<br>4、 TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据。<br>5、 TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。<br>6、 truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</li><li>视图和表的区别<br>1、视图是已经编译好的SQL语句，是基于SQL语句的结果集的可视化的表，而表不是。<br>2、视图没有实际的物理记录，而表有。<br>3、视图是窗口，表是内容。<br>4、视图是逻辑概念的存在，不占用物理空间；而表占用物理空间。<br>5、表可以及时对它进行修改；而视图只能用创建语句来修改。<br>6、视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL语句的集合。<br>7、从安全来说，视图可以防止用户直接接触表，因而用户不知道表结构。<br>8、表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。<br>9、视图的建立和删除只影响视图本身，不影响对应的表。</li><li>安全性操作<br>1、授权：grant 权限（列） on 表名 to 用户。<br>2、所有权限：all priviliges。<br>3、收回权限：revoke 权限（列） on 表名 from 用户。</li><li>完整性约束<br>1、主键约束：primary key<br>2、外键约束：foreign key<br>3、唯一约束：unique<br>4、检查约束：check<br>5、非空约束：not null</li><li>存储过程(procedure)和函数(function)区别<br>本质上它们都是存储程序。函数只能通过return语句返回单个值或表对象；而存储过程不允许执行return语句，但是可以通过output参数返回多个值。函数限制比较多，不能用临时变量，只能用表变量，还有一些函数都不可用等等；而存储过程的限制相对就比较少。函数可以嵌入在SQL语句中使用，可以在select语句中作为查询语句的一个部分调用；而存储过程一般是作为一个独立的部分来执行。</li><li>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？<br>如果表的存储引擎为MyISAM,那么Id会是18，因为MyISAM会将自增主键的最大的值存储到文件中，重启后数据也不会丢失；而如果存储引擎为Innodb,那么id将会为15，因为innodb只会将最大的自增主键存放在内存中，重启后会消失。</li><li>MySQL中的几种锁<br>1、MyISAM支持表锁，InnoDB支持表锁和行锁，默认为行锁<br>2、表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并发量最低<br>3、行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最高</li><li>Datetime、Timestamp 存储时间的区别<br>datetime与时区无关、timestamp与时区有关</li><li>MySQL B+树索引和Hash索引的区别<br>1、B+树是一个平衡的多叉树。B+树从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动。<br>2、哈希索引采用一定的哈希算法，把键值换成新的哈希值，检索时不需要类似B+树那样从根节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置。<br>3、区别：等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。<br>4、不适用场景：不支持范围查询；不支持索引完成排序；不支持联合索引的最左前缀匹配规则。</li><li>聚簇索引和非聚簇索引的区别<br>1、聚簇索引的顺序就是数据的物理存储顺序；非聚簇索引的解释是:索引顺序与数据物理排列顺序无关。<br>2、聚簇索引：索引的叶节点就是数据节点（索引值）。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</li></ul><hr><h3 id="MySQL面试常见手撕SQL题目汇总"><a href="#MySQL面试常见手撕SQL题目汇总" class="headerlink" title="MySQL面试常见手撕SQL题目汇总"></a>MySQL面试常见手撕SQL题目汇总</h3><p>用一条SQL 语句 查询出每门课都大于80 分的学生姓名<br>| name    | kecheng  | fenshu |<br>| 张三    | 语文      | 81     |<br>| 张三    | 数学      | 75     |<br>| 李四    | 语文      | 76     |<br>| 李四    | 数学      | 90     |<br>| 王五    | 语文      | 81     |<br>| 王五    | 数学      | 100    |<br>| 王五    | 英语      | 90     |</p><p>select name from table group by name having min(fenshu) &gt; 80;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不管是IT什么领域的开发人员，肯定都要求会一些数据库相关的知识，尤其是后端的开发人员，不仅要求掌握数据库相关的理论知识，还要求拥有很多的实际开发经验，通常而言MySQL已经成为软件开发领域的扛把子，因此这篇文章的相关知识也是从MySQL相关的知识而展开的。
    
    </summary>
    
    
      <category term="MySQL" scheme="https://kkcl.github.io/categories/MySQL/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="MySQL" scheme="https://kkcl.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux高频面试题</title>
    <link href="https://kkcl.github.io/Linux%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/Linux%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-24T06:20:55.240Z</published>
    <updated>2020-04-26T06:02:03.728Z</updated>
    
    <content type="html"><![CDATA[<p>目前用的比较多的操作系统大致可分为以下的几类：微软开发的windows系统、苹果开发的mac系统、开源的Linux系统，由于历史及操作体验性的相关原因，绝大部分人都是使用的windows或mac系统，针对Linux系统，使用的人群基本上围绕着应用开发者、运维人员展开。<a id="more"></a>这也从侧面说明掌握Linux系统的相关用法，已经慢慢的变成了一个对开发者的基本要求，而要自然的使用Linux系统必然少不了熟练掌握相关的Linux操作命令，本着既方便面试又方便日常的学习的目的，针对面试中出现的高频面试题特别进行了以下的总结。</p><hr><h3 id="Linux系统文件目录作用"><a href="#Linux系统文件目录作用" class="headerlink" title="Linux系统文件目录作用"></a>Linux系统文件目录作用</h3><ul><li>/bin<br>bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li>/boot<br>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li>/dev<br>dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li>/etc<br>这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li>/home<br>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li>/lib<br>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</li><li>/lost+found<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li>/media<br>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li>/mnt<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li>/opt<br>这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li>/proc<br>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器。</li><li>/root<br>该目录为系统管理员，也称作超级权限者的用户主目录。</li><li>/sbin<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li>/selinux<br>这个目录是Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</li><li>/srv<br>该目录存放一些服务启动之后需要提取的数据。</li><li>/sys<br>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。<br>sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。<br>该文件系统是内核设备树的一个直观反映。<br>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建</li><li>/tmp<br>这个目录是用来存放一些临时文件的。</li><li>/usr<br>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li>/usr/bin<br>系统用户使用的应用程序。</li><li>/usr/sbin<br>超级用户使用的比较高级的管理程序和系统守护程序。</li><li>/usr/src<br>内核源代码默认的放置目录。</li><li>/var<br>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li>/run<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</li></ul><h3 id="Linux常用的命令"><a href="#Linux常用的命令" class="headerlink" title="Linux常用的命令"></a>Linux常用的命令</h3><ul><li>查看某个程序是否运行<br>ps –ef|grep xxx[例如tomcat，显示进程的pid]</li><li>终止某个程序<br>kill -9 [pid]</li><li>查看文件<br>ls -al  [查找当前目录下所有的文件包括隐藏文件]</li><li>创建文件夹<br>mkdir xxx   [xxx为文件夹的名称]</li><li>删除文件夹<br>rmdir xxx   [xxx为文件夹的名称，只能删除空目录]</li><li>删除文件及其子文件<br>rm -rf xxx  [xxx为要删除的文件]</li><li>移动文件<br>mv /xxx/yyy /target  [将文件移动到目标文件夹下]<br>mv xxx yyy  [重命名文件将xxx修改为yyy]</li><li>解压tar包<br>tar –xvf xxx.tar  [其中xxx为jar包的名称]</li><li>启动tomcat的服务<br>./startup.sh</li><li>终止tomcat的服务<br>./shutdown.sh</li><li>查看端口是否被占用<br>netstat  -anp  | grep   xxx [xxx为端口号]</li><li>查看当前端口的使用情况<br>netstat   -nultp             [listen为已占用的状态]</li><li>对文件的内容进行统计<br>wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数</li></ul><ul><li>如果知道一个文件名称，怎么查这个文件在linux下的哪个目录<br>find / -name xxx             [xxx为文件的名称]</li><li>find相关的命令<br>find / -name httpd.conf　　   [在根目录下查找文件httpd.conf，表示在整个硬盘查找]<br>find /etc -name httpd.conf　　[在/etc目录下文件httpd.conf]<br>find /etc -name ‘srm‘　       [使用通配符(0或者任意多个)。表示在/etc目录下查找文件名中含有字符串‘srm’的文件]<br>find . -name ‘srm‘ 　　       [表示当前目录下查找文件名开头是字符串‘srm’的文件]<br>find / -amin -10 　　         [查找在系统中最后10分钟访问的文件(access time)]<br>find / -atime -2　　          [查找在系统中最后48小时访问的文件]<br>find / -empty 　　            [查找在系统中为空的文件或者文件夹]<br>find / -group cat 　　        [查找在系统中属于group为cat的文件]<br>find / -mmin -5 　　          [查找在系统中最后5分钟里修改过的文件]<br>find / -mtime -1 　　         [查找在系统中最后24小时里修改过的文件]<br>find / -user fred 　　        [查找在系统中属于fred这个用户的文件]<br>find / -size +10000c　        [查找出大于10000000字节的文件(c:字节，w:双字，k:KB，M:MB，G:GB)]<br>find / -size -1000k 　        [查找出小于1000KB的文件]</li></ul><ul><li>查看文件的指定行数<br>head -n 10 example.txt        [查看文件的前10行]<br>tail -n 10 example.txt        [查看文件的后10行]</li></ul><h3 id="vi-vim的相关命令"><a href="#vi-vim的相关命令" class="headerlink" title="vi/vim的相关命令"></a>vi/vim的相关命令</h3><ul><li>vi/vim通常可分为三种模式:正常模式、插入模式、命令模式</li><li>q（退出）、q!（强制退出）、w（保存）、wq（保存并退出）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前用的比较多的操作系统大致可分为以下的几类：微软开发的windows系统、苹果开发的mac系统、开源的Linux系统，由于历史及操作体验性的相关原因，绝大部分人都是使用的windows或mac系统，针对Linux系统，使用的人群基本上围绕着应用开发者、运维人员展开。
    
    </summary>
    
    
      <category term="Linux" scheme="https://kkcl.github.io/categories/Linux/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="Linux" scheme="https://kkcl.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>操作系统高频面试题</title>
    <link href="https://kkcl.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-24T04:17:07.476Z</published>
    <updated>2020-04-24T08:30:29.631Z</updated>
    
    <content type="html"><![CDATA[<p>无论是在踏出校园的校招技术面试中还是工作之后的社招面试中，操作系统相关的知识也是面试过程中不能逃脱的重要一环。平心而论，作为一名开发人员虽然在日常的工作中较少有机会用到这些知识，但是面试的过程中又不能说不会被问到，与其每次面试之前都大费周章的在网络上寻找个各种各样的操作系统面试题，还不如从日常的学习中从这些操作系统的高频面试题入手。<a id="more"></a>这样无论是以后的面试还是以后的学习过程中，都不需要再去浪费时间。</p><hr><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li>进程是什么<br>进程是具有一定独立功能的程序、它是系统进行资源分配和调度的一个独立单位，重点在系统调度和单独的单位，也就是说进程是可以独立运行的一段程序。</li><li>线程是什么<br>线程进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源。 在运行时，只是暂用一些计数器、寄存器和栈 。</li><li>进程与线程的关系<br>1、一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程（通常说的主线）<br>2、资源分配给进程，同一进程的所有线程共享该进程的所有资源<br>3、线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。<br>4、处理机分给线程，即真正在处理机上运行的是线程。<br>5、线程是指进程内的一个执行单元，也是进程内的可调度实体。</li><li>进程与线程的异同<br>1、调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。<br>2、并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行<br>3、拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。<br>4、系统开销：创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等，OS所付出的开销显著大于在创建或撤消线程时的开销；进程切换的开销也远大于线程切换的开销。</li></ul><h3 id="进程与线程的通信方式"><a href="#进程与线程的通信方式" class="headerlink" title="进程与线程的通信方式"></a>进程与线程的通信方式</h3><ul><li>进程的通信方式<br>1、管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。<br>2、有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。<br>3、信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br>4、消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。<br>5、信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。<br>6、共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。<br>7、套接字( socket ) ： 套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li><li>线程的通信方式<br>1、锁机制：包括互斥锁、条件变量、读写锁(互斥锁提供了以排他方式防止数据结构被并发修改的方法,读写锁允许多个线程同时读共享数据，而对写操作是互斥的,条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用)。<br>2、信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量。<br>3、信号机制(Signal)：类似进程间的信号处理线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</li></ul><h3 id="死锁相关的知识"><a href="#死锁相关的知识" class="headerlink" title="死锁相关的知识"></a>死锁相关的知识</h3><ul><li>什么是死锁<br>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</li><li>死锁产生的条件(有一个条件不成立，则不会产生死锁)<br>1、互斥条件：一个资源一次只能被一个进程使用<br>2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放<br>3、不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺<br>4、循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li><li>进程有哪些状态<br>1、就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源<br>2、运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数<br>3、阻塞状态： 进程等待某种条件，在条件满足之前无法执行</li><li>分页与分段的区别<br>1、段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。<br>2、段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定<br>3、段向用户提供二维地址空间；页向用户提供的是一维地址空间<br>4、段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制</li><li>进程同步的机智<br>1、原子操作、信号量机制、自旋锁管程、会合、分布式系统</li><li>守护、僵尸、孤儿进程的概念<br>1、守护进程：运行在后台的一种特殊进程，独立于控制终端并周期性地执行某些任务<br>2、僵尸进程：一个进程 fork 子进程，子进程退出，而父进程没有wait/waitpid子进程，那么子进程的进程描述符仍保存在系统中，这样的进程称为僵尸进程。<br>3、孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，这些子进程称为孤儿进程。（孤儿进程将由 init 进程收养并对它们完成状态收集工作)。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论是在踏出校园的校招技术面试中还是工作之后的社招面试中，操作系统相关的知识也是面试过程中不能逃脱的重要一环。平心而论，作为一名开发人员虽然在日常的工作中较少有机会用到这些知识，但是面试的过程中又不能说不会被问到，与其每次面试之前都大费周章的在网络上寻找个各种各样的操作系统面试题，还不如从日常的学习中从这些操作系统的高频面试题入手。
    
    </summary>
    
    
      <category term="操作系统" scheme="https://kkcl.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="操作系统" scheme="https://kkcl.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络高频面试题</title>
    <link href="https://kkcl.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://kkcl.github.io/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-04-23T03:46:08.228Z</published>
    <updated>2020-04-24T06:48:35.456Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名软件技术开发人员，无论是在在刚踏出大学校门的校招面试过程中还是在以后跳槽的社招面试过程中，计算机网络相关的面试问题始终是一道不能跨越的门槛，与其每次面试之前面对这方面的问题惴惴不安，倒不如从现在开始仔细总结这方面的问题，彻底搞定计算机网络方面的面试题。<a id="more"></a>因为一场技术面试的时间始终是有限制的，面试官不可能把所有的网络问题仔仔细细的全部问完，大部分的情况下都只会挑选一些常见的高频面试题，因此从这些高频网络面试题入手是很有必要的。</p><hr><h3 id="TCP和UDP的异同"><a href="#TCP和UDP的异同" class="headerlink" title="TCP和UDP的异同"></a>TCP和UDP的异同</h3><p>TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。<br>两者的主要区别是：</p><ul><li>TCP面向连接，UDP面向非连接即发送数据前不需要建立链接</li><li>TCP提供可靠的服务（数据传输），UDP无法保证</li><li>TCP面向字节流，UDP面向报文</li><li>TCP数据传输慢，UDP数据传输快</li></ul><h3 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h3><p>在TCP/IPX协议中，TCP协议提供可靠的链接服务，链接是通过三次握手进行初始化的。三次握手的目的在于同步链接双方的序列号和确认号并交换TCP窗口的大小信息。</p><ul><li>第一次握手建立起连接，客户端发送连接请求报文段，将SYN位置设置为1，Sequence Number为x,然后，客服端进入SYN_SEND状态，等待服务器确认。</li><li>第二次握手，服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Ack Number的值为1，Sequence NUmber的值为y,同时服务器端将上述的所有的信息放到一个报文段(即SYN+ACK报文段中)，一并发送给客户端，此时服务器进入SYN_RECV状态。</li><li>第三次握手，客户端接收到SYN——ACK报文段，然后将ACK Number的值设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕后，客户端和服务器端都进入ESTABLISHED状态，完成TCP的三次握手。</li></ul><h3 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h3><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p><ul><li>第一次挥手(FIN=1，seq=x)<br>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据，发送完毕后，客户端进入 FIN_WAIT_1 状态</li><li>第二次挥手(ACK=1，ACKnum=x+1)<br>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</li><li>第三次挥手(FIN=1，seq=y)<br>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</li><li>第四次挥手(ACK=1，ACKnum=y+1)<br>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态</li></ul><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><ul><li>从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源。</li><li>从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</li><li>从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。</li><li>就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。</li><li>从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</li></ul><h3 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h3><ul><li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ul><h3 id="Session-与-Cookie-的对比"><a href="#Session-与-Cookie-的对比" class="headerlink" title="Session 与 Cookie 的对比"></a>Session 与 Cookie 的对比</h3><ul><li>实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；</li><li>大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关。</li><li>安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全。</li><li>服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。</li><li>Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名软件技术开发人员，无论是在在刚踏出大学校门的校招面试过程中还是在以后跳槽的社招面试过程中，计算机网络相关的面试问题始终是一道不能跨越的门槛，与其每次面试之前面对这方面的问题惴惴不安，倒不如从现在开始仔细总结这方面的问题，彻底搞定计算机网络方面的面试题。
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://kkcl.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="高频" scheme="https://kkcl.github.io/tags/%E9%AB%98%E9%A2%91/"/>
    
      <category term="面试题" scheme="https://kkcl.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="网络" scheme="https://kkcl.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>2020，路在何方？</title>
    <link href="https://kkcl.github.io/wechat/2020%EF%BC%8C%E8%B7%AF%E5%9C%A8%E4%BD%95%E6%96%B9/"/>
    <id>https://kkcl.github.io/wechat/2020%EF%BC%8C%E8%B7%AF%E5%9C%A8%E4%BD%95%E6%96%B9/</id>
    <published>2020-04-15T04:07:59.513Z</published>
    <updated>2020-04-15T04:14:38.667Z</updated>
    
    <content type="html"><![CDATA[<p>将时间拨回两年前，回到那个纸短情长闷热的夏季，那时相信应该没有多少人会对未来的前景持悲观态度。那个夏天没有焦躁、也没有无奈、更没有彷徨 ，有的只是青春的激情、躁动、向往，然而一场疫情的到来，却让一切全部发生了骤变，化为了泡影。<a id="more"></a></p><p>从目前的情况来看，无论是从企业发布的招聘需求数量还是从求职的人数来看，两边都呈现出极端化。一方面企业为了在这次疫情中尽最大的可能保住公司的现金流，不是采取裁员的措施，就是不断的降低企业内部员工的薪资，有的企业把这样的行为称之为共度难关。</p><p>从他们给员工灌输的思想来看，一旦企业无法存活下去，员工的日子也好不到哪里去，与其到时候公司倒闭破产所有人被迫到处求职，还不如这个时候无条件的听从领导的安排，自觉、主动的接受公司的降薪要求。</p><p>另一方面因为各大公司不约而同的进行裁员、降薪等手段，造成现在的就业市场上存在着很大一批的求职者，有些人待业的时间甚至超过半年之久，在这样的情形下，非常有可能其中的一些人宁愿采取降薪的形式来入职那些他们原本就看不上的企业。</p><p>类似于田忌赛马的机制，一旦那些具有高竞争力的人愿意降薪入职那些低一阶的职位，往往意味着那些原先能力只适合这些职位的人会失去这一类的职位，这样的逻辑层层叠加，到最后总会有一些技能条件不如其他求职者的人会失去工作，最后为了生存不得不从事一些他们之前自以为绝对不可能从事的职业，比如目前已经屡见不鲜的程序员群体转行送外卖、开滴滴等。不是看不起这些职业，单纯的从个人的角度来看，只要是能够为这个社会创造价值，都应当得到他们应该拥有的尊重。</p><p>从这些已经发生的现实情况观察，我们不难得出今年的这个求职市场，已经的确相对于往年冷清了好多。越是这样的时候，作为普通个体的我们就越应该好好的思考下接下来的路我们应该怎样走。</p><p>不是不看好未来的经济发展的前景，从长远的经济大趋势来看，就像国家有关政府机构预测的那样，未来至少10年的时间内，经济长期稳定向好的大盘并没有发生什么本质上的改变，也就是说稳定增长的基本盘不可能发生什么大的动摇。在这样的情况下，普通群体进行阶级跃进、实现财富自由的机会仍然存在，只不过相比之前的十年可能更加的辛苦些。</p><p>另外从大的方面出发来看，受益于高等教育持续的大规模扩招，越往后，文凭的价值会缩水的更加厉害。反映在职场的现实中非常有可能出现某些企业的招聘需求不断提升的过程，未来某些企业的招聘岗位学历要求十分有可能从硕士学历开始要求起步，不说这样的要求是否合理，一旦这样的事情发生，基本上也就宣告了学历制度的正式死亡，到那时真的可能出现如同马云所言“你花费大量学费取得的学历文聘，很有可能只是一份你向学校缴纳学费的凭证”。</p><p>到那时在大的社会背景下，那些依靠学历背景背书，本身没有什么强大的竞争力的人很可能面临着出局的风险。同样也不是说学历不重要，仅仅从一个入职职场数载的职场老鸟的角度来看，越往后学历不仅对于普通人十分的重要，反而可以说是至关重要，但学历也只能确保你投递意向岗位的时候保证你拥有一个面试的机会，至于后续的结果怎么样，还得凭借自己的个人实力。就像有些地区的农村人常讲的一句话，我为什么非要有个儿子，这玩意就像原子弹一样，虽然有可能一辈子用不上，但是不能没有。</p><p>职场大环境已然如此，作为普通的个体最好做到未雨绸缪。特别是像今年一样，迫于疫情的压力，有的公司干脆直接不发或者少发工资，在这样的情况下，很多人的收入来源也基本上断了，可是各种贷款支出费用还是需要偿还的啊。越往后，遭遇这样的日子的概率可能会更加的频繁，作为个人最好还是尽量的拓宽自己的收入来源渠道，要不然要是哪天人到中年面临上有老、下有小的窘迫境地，真不知该如何处理。</p><p>在此还是建议大部分上班族在2020年开始着手准备一两份自己的副业，确保在主业收入断掉之后还有副业来做暂时性的支撑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将时间拨回两年前，回到那个纸短情长闷热的夏季，那时相信应该没有多少人会对未来的前景持悲观态度。那个夏天没有焦躁、也没有无奈、更没有彷徨 ，有的只是青春的激情、躁动、向往，然而一场疫情的到来，却让一切全部发生了骤变，化为了泡影。
    
    </summary>
    
    
      <category term="公众号文章" scheme="https://kkcl.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="wechat" scheme="https://kkcl.github.io/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="https://kkcl.github.io/%E5%89%91%E6%8C%87offer/"/>
    <id>https://kkcl.github.io/%E5%89%91%E6%8C%87offer/</id>
    <published>2020-04-13T08:10:43.753Z</published>
    <updated>2020-04-19T03:27:35.903Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>随着国内移动互联网的流量红利见顶，从需求端的角度来看，对软件研发人才的需求已经出现了过剩的现象，再加上疫情的冲击，大部分的公司为了在激烈的市场竞争中存活下来，不是采取裁员的措施，就是冻结公司的相关的招聘名额。<a id="more"></a>在这样的情况下，可以说目前的市场针对中低端的软件开发人才已经出现了过剩的现象，说的难听点基本上已经处于存量竞争的状态，大环境下，各大IT公司纷纷加大技术面试的难度借此刷掉一部分不合格的求职者，其中算法成为他们屡试不爽的一招，为了有效的打掉求职过程中的这道拦路虎，有必要针对高频算法题进行一定的练习。</p></blockquote><h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><ul><li><a href="#数组中重复的数字">数组中重复的数字</a></li><li><a href="#二维数组中的查找">二维数组中的查找</a></li><li><a href="#替换空格">替换空格</a></li><li><a href="#从尾到头打印链表">从尾到头打印链表</a></li><li><a href="#用两个栈实现队列">用两个栈实现队列</a></li><li><a href="#斐波那契数列">斐波那契数列</a></li><li><a href="#青蛙跳台阶问题">青蛙跳台阶问题</a> </li><li><a href="#二进制中1的个数">二进制中1的个数</a></li><li><a href="#打印从1到最大的n位数">打印从1到最大的n位数</a></li><li><a href="#删除链表的节点">删除链表的节点</a></li><li><a href="#调整数组顺序使奇数位于偶数前面">调整数组顺序使奇数位于偶数前面</a></li></ul><h3 id="中等模式"><a href="#中等模式" class="headerlink" title="中等模式"></a>中等模式</h3><ul><li>重建二叉树</li><li>矩阵中的路径</li></ul><h3 id="困难模式"><a href="#困难模式" class="headerlink" title="困难模式"></a>困难模式</h3><ul><li>正则表达式匹配</li><li>序列化二叉树</li></ul><hr><p><span id = "数组中重复的数字">数组中重复的数字</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道</span><br><span class="line">有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">2 &lt;&#x3D; n &lt;&#x3D; 100000</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int findRepeatNumber(int[] nums) &#123;</span><br><span class="line">        int repeat &#x3D; -1;</span><br><span class="line">        Set&lt;Integer&gt; set &#x3D; new HashSet&lt;Integer&gt;();</span><br><span class="line">        for(int num : nums)&#123;</span><br><span class="line">            if(!set.add(num))&#123;</span><br><span class="line">                repeat &#x3D; num;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id = "二维数组中的查找">二维数组中的查找</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序</span><br><span class="line">排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</span><br><span class="line"></span><br><span class="line">现有矩阵 matrix 如下：</span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 target &#x3D; 5，返回 true。</span><br><span class="line">给定 target &#x3D; 20，返回 false。</span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 1000</span><br><span class="line">0 &lt;&#x3D; m &lt;&#x3D; 1000</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;</span><br><span class="line">        if(matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int row &#x3D; matrix.length;</span><br><span class="line">        int col &#x3D; matrix[0].length;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; row; i++)&#123;</span><br><span class="line">            for(int j &#x3D; 0; j &lt; col; j++)&#123;</span><br><span class="line">                if(target &#x3D;&#x3D; matrix[i][j])&#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解法二</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;</span><br><span class="line">        if(matrix &#x3D;&#x3D; null || matrix.length &#x3D;&#x3D; 0 || matrix[0].length &#x3D;&#x3D; 0)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int rows &#x3D; matrix.length;</span><br><span class="line">        int cols &#x3D; matrix[0].length;</span><br><span class="line">        int row &#x3D; 0;</span><br><span class="line">        int col &#x3D; cols - 1;</span><br><span class="line">        while(row &lt; rows &amp;&amp; col &gt;&#x3D; 0)&#123;</span><br><span class="line">           int num &#x3D; matrix[row][col];</span><br><span class="line">            if(target &#x3D;&#x3D; num)&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;else if(target &lt; num)&#123;</span><br><span class="line">                col--;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                row++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id = "二维数组中的查找">二维数组中的查找</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span><br><span class="line"></span><br><span class="line">输入：s &#x3D; &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">0 &lt;&#x3D; s 的长度 &lt;&#x3D; 10000</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String replaceSpace(String s) &#123;</span><br><span class="line">        return s.replaceAll(&quot; &quot;, &quot;%20&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解法二</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public String replaceSpace(String s) &#123;</span><br><span class="line">        int length &#x3D; s.length();</span><br><span class="line">        char[] array &#x3D; new char[length * 3];</span><br><span class="line">        int size &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            char c &#x3D; s.charAt(i);</span><br><span class="line">            if (c &#x3D;&#x3D; &#39; &#39;) &#123;</span><br><span class="line">                array[size++] &#x3D; &#39;%&#39;;</span><br><span class="line">                array[size++] &#x3D; &#39;2&#39;;</span><br><span class="line">                array[size++] &#x3D; &#39;0&#39;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                array[size++] &#x3D; c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String newStr &#x3D; new String(array, 0, size);</span><br><span class="line">        return newStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id = "从尾到头打印链表">从尾到头打印链表</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line">输入：head &#x3D; [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">0 &lt;&#x3D; 链表长度 &lt;&#x3D; 10000</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack &#x3D; new Stack&lt;ListNode&gt;();</span><br><span class="line">        ListNode temp &#x3D; head;</span><br><span class="line">        while(temp !&#x3D; null)&#123;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">            temp &#x3D; temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        int size &#x3D; stack.size();</span><br><span class="line">        int [] arr &#x3D; new int[size];</span><br><span class="line">        for(int i &#x3D; 0; i &lt; size; i++)&#123;</span><br><span class="line">            arr[i] &#x3D; stack.pop().val;</span><br><span class="line">        &#125;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解法二</span><br><span class="line">public int[] reversePrint(ListNode head) &#123;</span><br><span class="line">       ListNode p1 &#x3D; head;</span><br><span class="line">       int size &#x3D; 0;</span><br><span class="line">       while (p1 !&#x3D; null) &#123;</span><br><span class="line">           size++;</span><br><span class="line">           p1 &#x3D; p1.next;</span><br><span class="line">       &#125;</span><br><span class="line">       int[] ints &#x3D; new int[size];</span><br><span class="line">       while (head !&#x3D; null) &#123;</span><br><span class="line">           ints[--size] &#x3D; head.val;</span><br><span class="line">           head &#x3D; head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return ints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id = "用两个栈实现队列">用两个栈实现队列</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">1 &lt;&#x3D; values &lt;&#x3D; 10000</span><br><span class="line">最多会对 appendTail、deleteHead 进行 10000 次调用</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解法二</span><br></pre></td></tr></table></figure><p><span id = "斐波那契数列">斐波那契数列</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</span><br><span class="line">F(0) &#x3D; 0,   F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br><span class="line"></span><br><span class="line">斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br><span class="line"></span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 5</span><br><span class="line">输出：5</span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 100</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int fib(int n) &#123;</span><br><span class="line">        if(n &#x3D;&#x3D; 0)</span><br><span class="line">            return 0;</span><br><span class="line">        int[] result &#x3D; new int[n + 1];</span><br><span class="line">        result[1] &#x3D; 1;</span><br><span class="line">        for(int i &#x3D; 2; i &lt;&#x3D; n; i++)</span><br><span class="line">            result[i] &#x3D; (result[i - 2] + result[i - 1])  % 1000000007;</span><br><span class="line">        return result[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id = "青蛙跳台阶问题">青蛙跳台阶问题</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</span><br><span class="line">答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 2</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">输入：n &#x3D; 7</span><br><span class="line">输出：21</span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">0 &lt;&#x3D; n &lt;&#x3D; 100</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int numWays(int n) &#123;</span><br><span class="line">       if(n &#x3D;&#x3D; 0)</span><br><span class="line">            return 1;</span><br><span class="line">        if(n &lt;&#x3D; 2)</span><br><span class="line">            return n;</span><br><span class="line">        long fibOne &#x3D; 1;</span><br><span class="line">        long fibTow &#x3D; 2;</span><br><span class="line">        long res &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            res &#x3D; (fibOne + fibTow) % 1000000007;</span><br><span class="line">            fibOne &#x3D; fibTow;</span><br><span class="line">            fibTow &#x3D; res;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id = "旋转数组的最小数字">旋转数组的最小数字</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，</span><br><span class="line">输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</span><br><span class="line"></span><br><span class="line">输入：[3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">输入：[2,2,2,0,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><span id = "二进制中1的个数">二进制中1的个数</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，</span><br><span class="line">有 2 位是 1。因此，如果输入 9，则该函数输出 2。</span><br><span class="line"> </span><br><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    &#x2F;&#x2F; you need to treat n as an unsigned value</span><br><span class="line">    public int hammingWeight(int n) &#123;</span><br><span class="line">      int res&#x3D;0;</span><br><span class="line">        while(n!&#x3D;0)&#123;</span><br><span class="line">            if((n&amp;1)&#x3D;&#x3D;1)&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            n&gt;&gt;&gt;&#x3D;1; &#x2F;&#x2F;无符号右移一位</span><br><span class="line">          &#x2F;&#x2F;n &amp;&#x3D; n - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解法二</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public int hammingWeight(int n) &#123;</span><br><span class="line">       return Integer.toBinaryString(n).replaceAll(&quot;0&quot;, &quot;&quot;).length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id = "打印从1到最大的n位数">打印从1到最大的n位数</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3</span><br><span class="line">一直到最大的 3 位数 999。</span><br><span class="line"></span><br><span class="line">输入: n &#x3D; 1</span><br><span class="line">输出: [1,2,3,4,5,6,7,8,9]</span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">用返回一个整数列表来代替打印</span><br><span class="line">n 为正整数</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] printNumbers(int n) &#123;</span><br><span class="line">        int[] res &#x3D; new int[(int)Math.pow(10,n) - 1];</span><br><span class="line">        for(int i &#x3D; 0;i &lt; res.length;i++)&#123;</span><br><span class="line">            res[i] &#x3D; i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id = "删除链表的节点">删除链表的节点</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</span><br><span class="line">返回删除后的链表的头节点。</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 5</span><br><span class="line">输出: [4,1,9]</span><br><span class="line">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="line"></span><br><span class="line">输入: head &#x3D; [4,5,1,9], val &#x3D; 1</span><br><span class="line">输出: [4,5,9]</span><br><span class="line">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">题目保证链表中节点的值互不相同</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode next;</span><br><span class="line"> *     ListNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteNode(ListNode head, int val) &#123;</span><br><span class="line">        if(head &#x3D;&#x3D; null) return head;</span><br><span class="line">        if(head.val &#x3D;&#x3D; val) return head.next;</span><br><span class="line"></span><br><span class="line">        ListNode cur &#x3D; head;</span><br><span class="line">        while(cur.next !&#x3D; null &amp;&amp; cur.next.val !&#x3D; val)&#123;</span><br><span class="line">            cur &#x3D; cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;删除指定节点</span><br><span class="line">        if(cur.next !&#x3D; null) cur.next &#x3D; cur.next.next; </span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解法二</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public ListNode deleteNode(ListNode head, int val) &#123;</span><br><span class="line">        if(head.val&#x3D;&#x3D;val) return head.next;</span><br><span class="line">    head.next &#x3D; deleteNode(head.next,val);</span><br><span class="line">    return head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id = "调整数组顺序使奇数位于偶数前面">调整数组顺序使奇数位于偶数前面</span></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于</span><br><span class="line">数组的前半部分，所有偶数位于数组的后半部分。</span><br><span class="line"></span><br><span class="line">输入：nums &#x3D; [1,2,3,4]</span><br><span class="line">输出：[1,3,2,4] </span><br><span class="line">注：[3,1,2,4] 也是正确的答案之一。</span><br><span class="line"></span><br><span class="line">限制</span><br><span class="line">1 &lt;&#x3D; nums.length &lt;&#x3D; 50000</span><br><span class="line">1 &lt;&#x3D; nums[i] &lt;&#x3D; 10000</span><br><span class="line"></span><br><span class="line">解法一</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] exchange(int[] nums) &#123;</span><br><span class="line">        int slow &#x3D; 0, fast &#x3D; 0;</span><br><span class="line">        while(fast &lt; nums.length)&#123;</span><br><span class="line">            if((nums[fast]&amp;1) &#x3D;&#x3D; 1) swap(nums,slow++,fast);</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swap(int [] nums, int a, int b)&#123;</span><br><span class="line">        int temp &#x3D; nums[a];</span><br><span class="line">        nums[a] &#x3D; nums[b];</span><br><span class="line">        nums[b ] &#x3D; temp;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解法二</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] exchange(int[] nums) &#123;</span><br><span class="line">        int low &#x3D; 0, high &#x3D; nums.length - 1;</span><br><span class="line">        while(low &lt; high)&#123;</span><br><span class="line">            while(nums[low] % 2 !&#x3D; 0 &amp;&amp; low &lt; high) low++;</span><br><span class="line">            while(nums[high] % 2 &#x3D;&#x3D; 0 &amp;&amp; low &lt; high) high--;</span><br><span class="line"></span><br><span class="line">            int temp &#x3D; nums[low];</span><br><span class="line">            nums[low] &#x3D; nums[high];</span><br><span class="line">            nums[high] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">解法三</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int[] exchange(int[] nums) &#123;</span><br><span class="line">        if(nums.length &#x3D;&#x3D; 0) return nums;</span><br><span class="line">        int start &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">            if(nums[i] % 2 &#x3D;&#x3D;1)&#123;</span><br><span class="line">                int temp &#x3D; nums[i];</span><br><span class="line">                nums[i] &#x3D; nums[start];</span><br><span class="line">                nums[start] &#x3D; temp;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;随着国内移动互联网的流量红利见顶，从需求端的角度来看，对软件研发人才的需求已经出现了过剩的现象，再加上疫情的冲击，大部分的公司为了在激烈的市场竞争中存活下来，不是采取裁员的措施，就是冻结公司的相关的招聘名额。
    
    </summary>
    
    
      <category term="算法" scheme="https://kkcl.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://kkcl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="剑指offer" scheme="https://kkcl.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>使用Java将word转换成pdf</title>
    <link href="https://kkcl.github.io/%E4%BD%BF%E7%94%A8Java%E5%B0%86word%E8%BD%AC%E6%8D%A2%E6%88%90pdf/"/>
    <id>https://kkcl.github.io/%E4%BD%BF%E7%94%A8Java%E5%B0%86word%E8%BD%AC%E6%8D%A2%E6%88%90pdf/</id>
    <published>2020-04-13T02:49:48.339Z</published>
    <updated>2020-04-13T03:01:56.452Z</updated>
    
    <content type="html"><![CDATA[<p>在日常的学习中，我们经常会碰到需要将word文件转换为pdf的情形，因为大部分的情况下一些免费的线上网站都只能转换一页，同时由于信息保密的考虑，大部分的人还是不愿意在这样的网站进行操作的。那么是否有简单的方法可以将word转换为pdf呢？其实作为一名开发人员，只要经过简单的网络搜索都应该能够实现，以下就是博主的解决方案。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import com.aspose.words.Document;</span><br><span class="line">import java.io.File;</span><br><span class="line"> </span><br><span class="line">public class WordToPdf &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">             &#x2F;&#x2F;doc路径</span><br><span class="line">            Document document &#x3D; new Document(&quot;C:\\Users\\CHENG\\Desktop\\数学建模定稿.docx&quot;);</span><br><span class="line">            &#x2F;&#x2F;pdf路径</span><br><span class="line">            File outputFile &#x3D; new File(&quot;C:\\Users\\CHENG\\Desktop\\数学建模定稿.pdf&quot;);</span><br><span class="line">            &#x2F;&#x2F;操作文档保存</span><br><span class="line">            document.save(outputFile.getAbsolutePath(), com.aspose.words.SaveFormat.PDF);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考资料：<a href="https://blog.csdn.net/qq_38061755/article/details/82730139" target="_blank" rel="noopener">https://blog.csdn.net/qq_38061755/article/details/82730139</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常的学习中，我们经常会碰到需要将word文件转换为pdf的情形，因为大部分的情况下一些免费的线上网站都只能转换一页，同时由于信息保密的考虑，大部分的人还是不愿意在这样的网站进行操作的。那么是否有简单的方法可以将word转换为pdf呢？其实作为一名开发人员，只要经过简单的网络搜索都应该能够实现，以下就是博主的解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具代码" scheme="https://kkcl.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BB%A3%E7%A0%81/"/>
    
    
      <category term="word" scheme="https://kkcl.github.io/tags/word/"/>
    
      <category term="pdf" scheme="https://kkcl.github.io/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>2020，我们都是见证历史的人！</title>
    <link href="https://kkcl.github.io/wechat/2020%EF%BC%8C%E6%88%91%E4%BB%AC%E9%83%BD%E6%98%AF%E8%A7%81%E8%AF%81%E5%8E%86%E5%8F%B2%E7%9A%84%E4%BA%BA/"/>
    <id>https://kkcl.github.io/wechat/2020%EF%BC%8C%E6%88%91%E4%BB%AC%E9%83%BD%E6%98%AF%E8%A7%81%E8%AF%81%E5%8E%86%E5%8F%B2%E7%9A%84%E4%BA%BA/</id>
    <published>2020-04-11T07:59:52.343Z</published>
    <updated>2020-04-13T03:51:25.317Z</updated>
    
    <content type="html"><![CDATA[<p>2020年注定是一个不平凡的年份，而身处这个时代的我们，每一个人都是历史的见证者、亲历者、参与者。不管你承不承认，裹挟于时代的洪流之中，每一天、每一刻我们都被历史的车轮推着走的，而每一道车轮轨迹的背后，都是一串串历史的印记，而2020年历史车轮遗留下的这串印记，必将注定特别的与众不同。</p><a id="more"></a><p>自新型冠状病毒发生以来，为了在最大限度上阻断病毒在人群中的传播途径，全国上下不约而同的采取了非常严厉的防控措施，即使是到今天，在一些重点地区这样的管控措施依然没有放松的迹象。虽然单就目前全国的情况来看，病毒的传播趋势已经被阻断了，但在一些地区，还存在着少量的无症状感染者，这些携带病毒的存量人员一天不清除干净，全国上下一天就得不到安宁，在这样的情形下，莫说允许一部分公司先行进行复工，就是能不能恢复到以前那样的生活状态还是个重大的问题。</p><p>按照往年的惯例，再过两个多月的时间，就应该迎来了一年一度的高考时间，可今年由于疫情的缘故，一些地区即使是到今天也未能进行正常的复课，虽然说可以采取网上直播教学的方法，但这种方式究其本质上而言并不适合大规模的推广。首先我们不得不承认的一个现实情况是：在我们这个社会中确实是存在贫富差距的，一些在我们看来非常稀松平常的事情，在一些特殊的家庭可能即使拼尽全力也未尝能够实现。</p><p>直播方式虽然方便，但同时也要求上课的学生群体必须具备有网、有智能设备的条件，在一些贫困的学生家庭，别说具备接入网络的条件，就是能不能有一部能够接入网络的智能手机还是个问题，要不然国家有关部门也不会明令在此期间严格禁止教师直播上课或录课。究其根本还是考虑到一个教育的公平问题。</p><p>如果按照往些年的情况部署，高考应该是定于每年的6月7号到8号，可今年由于疫情的原因满打满算只剩两个多月时间，长时间脱离课堂的情况下，不要说学生能否保持原先的学习状态积极的备战高考，就是有这样的心思，也估计很难确保有一个适合的学习的环境。同时由于不同家庭父母之间所受教育的差异，在这段时间内可能对待孩子的管理态度也不尽相同，这也在一定程度上造成了教育的不公平性。可能也是考虑到这种实际情况，在经过慎重的考虑后党中央、国务院还是做出了高考延期一个月的决定。</p><p>这个决定一经媒体播出，已然成为了一个全民关注的历史事件，要知道即使是在非典肆虐的2003年，高考也没有向今年一样推迟过，从这个角度来看，2020年我们见证的第一个历史就是延迟高考。</p><p>那么高考的延迟对于我们普通人而言又意味着什么呢？首先非常重要的一点就是不管未来疫情到底在何时结束，线上教育一定会迎来一大波红利发展期，线下的传统授课方式也可能迎来巨大的冲击，一些传统的教育巨头如新东方、好未来等必将加快向线上转移的速度，与此同时一些具有真才实学的个体也能收获一大波线上的教育红利。围绕着这个战场，可能又将迎来一波血腥的厮杀。</p><p>到今天为止，美国的确诊病例已经超过40w，这还是已经确诊的病例的数量，未确诊的人数还不知道有多少，如果按照目前的这个人数增加的速度来看，相信要不了多长时间，美国的确诊人数应该会超过50w。</p><p>在此之前，美国的股市已经发生过几次熔断事件，要知道美国股市在过去的几十年中也只不过发生过一次熔断，而这回由于新冠疫情的原因，不到一年的时间就接二连三的发生几次股市熔断的情况了，这也从侧面说明当今的全球资本并不相信特朗普政府能够有能力控制住这场疫情，基于这样的推测，大量的资金可能会在今年内从美国股市抽身离场，美国万股齐跌的状况还暂时不能确定到底什么时候到头。但资本自身拥有的对资本繁殖的狂热追求，相信只要从美国股市抽身，在很大程度上会来到资本更安全、回报率更高的中国市场。估计下半年，中国股市会迎来大量的全球资本热钱的涌入，只要美国的疫情一天得不到控制，资本就一天不会离开中国。</p><p>与美国的情况恰恰相反，虽然疫情“首先”在我国发现，但截至到目前，全国上下已经基本上控制住了这场疫情，虽然目前还没有彻底的消灭掉病毒，但与美国这种大爆发的情况相比还是比较乐观的，按照国内有关专家的说法，即使有些地区存在一定数量的未确诊病例，相信在现在的严格防控的措施面前，也绝对不会再出现武汉地区那种大范围的爆发情况出现。</p><p>基于目前欧美国家已经成为此次疫情爆发的重灾区，相信在未来的半年内，欧美国家基本不可能恢复到以往的那种正常的生产状态下，除非他们不怕牺牲，搞大规模的群体免疫政策，一旦这样的措施以立法的形式执行，不仅对中国、对全世界各个国家的人民来说都是一场灾难。从个人的角度来看，无论说作为普通的老百姓群体，还是稍微有点智商的政治家都不太可能执行这样的政策。</p><p>所以，这些国家都先后不约而同的采取了封国的措施，给全球的经济造成了很大的不确定性。</p><p>今年，无论是从宏观的角度还是从微观的角度来看，对个人和企业都是一道生死存亡的考验。企业要生存、员工要工资，国家要完成年前制定的一系列gdp目标，如果还不采取有效的经济刺激政策，估计今年相关的经济数据应该不会太好看。基于这样的猜测，在此大胆的预测几年过后向2008年的金融危机一样，两到三年的时间，肯定又会出现2010年以后那样对经济产生翻天覆地影响的移动互联网那样的爆发潮，对于我们这样的普通个体而言，往往这样的时刻就会成为我们改变自身命运的重要转机窗口，抓住了不仅顺利晋级上一个阶层实现财富自由，抓不住又不知道这样的机会又会在未来的哪一个时刻出现。</p><p>从我们国家目前的发展情况来看，工业化、城镇化已经基本上进入了中后期，属于普通人的机会也越来越稀少，如果再不好好抓住最后的黄金十年，普通人有可能再无出头之日。至于我们的国家的前途命运，如果还按照总设计师规划的路径那样一步一个脚印那样走，相信只需要不到20年的时间，我们肯定能够迎来伟大复兴的高光时刻。</p><p>2020年，不仅对企业，对个人同样至关重要，毕竟我们可都是见证历史的人！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2020年注定是一个不平凡的年份，而身处这个时代的我们，每一个人都是历史的见证者、亲历者、参与者。不管你承不承认，裹挟于时代的洪流之中，每一天、每一刻我们都被历史的车轮推着走的，而每一道车轮轨迹的背后，都是一串串历史的印记，而2020年历史车轮遗留下的这串印记，必将注定特别的与众不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="公众号文章" scheme="https://kkcl.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="wechat" scheme="https://kkcl.github.io/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>武汉物理解封容易，人心解封却很难！</title>
    <link href="https://kkcl.github.io/wechat/%E6%AD%A6%E6%B1%89%E7%89%A9%E7%90%86%E8%A7%A3%E5%B0%81%E5%AE%B9%E6%98%93,%E4%BA%BA%E5%BF%83%E8%A7%A3%E5%B0%81%E5%8D%B4%E5%BE%88%E9%9A%BE/"/>
    <id>https://kkcl.github.io/wechat/%E6%AD%A6%E6%B1%89%E7%89%A9%E7%90%86%E8%A7%A3%E5%B0%81%E5%AE%B9%E6%98%93,%E4%BA%BA%E5%BF%83%E8%A7%A3%E5%B0%81%E5%8D%B4%E5%BE%88%E9%9A%BE/</id>
    <published>2020-04-08T14:42:52.384Z</published>
    <updated>2020-04-10T07:18:12.935Z</updated>
    
    <content type="html"><![CDATA[<p>​今天是2020年4月8日，历史将会铭记这个特殊的日子。经过整整76天漫长的等待之后，湖北省武汉市终于打开了尘封许久的通道大门，这意味着从今天开始，整个湖北省都将有序放开省内省外人员流动限制，从这这点而言，以湖北为重灾区的疫情主战场已经取得了重大的胜利，真正达到了总书记所强调的武汉胜则湖北胜，湖北胜则全国胜的要求。然而有时候物理上的解封还相对容易，可如何消除湖北省以外，各地居民心底上的枷锁、戒备却还是个值得研究的重要命题。</p><a id="more"></a><p>自疫情发生以来，全国各地共选派330多支医疗队，超过4万名医务人员驰援湖北。其中，重症医学科、感染科、呼吸科、循环内科的专业人员就达到了16000多人。可以说，这样的规模、这样的力度在共和国的历史上还是屈指可数的。为了战胜这场疫情，可以说全国除湖北以外的各省市几乎是把自家的医疗精英家底尽数都暂时性的搬去了湖北省，在这样的支援力度下，同时加上英雄的城市、英雄的人民的鼎力配合，这场战役从某种程度上来说结局注定是美好的，事实也的确如此。</p><p>疫情初期，为了有效的缓解人等床的现实情况，国家有关部门负责同志火速商谈，最终决定借鉴北京小汤山医院模式，立即开建新的收治医院，于是在10天之内雷神山、火神山相继拔地而起，再一次重新向世人刷新了中国速度。根据事后有关人士采访的资料得知，为了支援雷神山、火神山医院的建设，从全国各地赶来的建筑工人在最高峰的时候一度超过5000人同时在工地上进行昼夜不停的施工，有的建筑工人甚至一连好几天都奋战在建设的工地上，一刻也没有合过眼，只为了早日能把这两座能救命的医院建设好投入使用。这些人同样也应该像那些支援武汉疫情抗战的医生、护士一样，得到应该有的荣誉，他们同样也是我们这个时代的英雄。</p><p>如今两个多月的时间已经过去，当初紧急筹建用来收治病人的雷神山、火神山医院也完成了属于他们的历史使命，关门封舱。湖北地区更是从累计确诊人数8万多人下降到现在医院治疗人数不足1000人，估计在不远的未来，能够实现治疗人数彻底清零。在这场无声的战役中，湖北省内的全体居民为了战役的胜利付出了很多，但他们却远远没有没有得到该有的尊重。</p><p>目前，虽然湖北地区已经解除了离汉离鄂通道，许多人也趁这段时间赶紧外出打工就业，争取把这段时间失去的损失弥补回来，但现实的情况却不是非常的理想，一些地区不是明令要求湖北籍的员工不得未经请示就返回，就是要求进行两周的隔离，这些措施虽然是合理的，但就一些失去收入已经两个多月的湖北人而言，每天几百块的隔离费用已经在无形中打退了许多人的务工念想，在这些人的眼中，与其白白的花费几千元的隔离费用，还不如继续呆在家里等待下一步的通知。</p><p>其实跟这些小事相比，现在湖北人最难以忍受的就是只要出省务工，在许多外省人的眼里，自己不仅得不到他们中有些人的一丝丝同情，反而成为了他们眼中的灾星，更有甚者唯恐避之不及，彷佛疫情之后的湖北人成了众矢之的。</p><p>有些湖北人本来打算返京复工，可当填完必要的申报材料之后，还未被审批放行，千里之外的歧视早已经随着5G的网络飞速而来。有些合租的湖北人，刚询问合租室友是否能够居家隔离，下一秒就有人直接背地里打电话给房东，威吓到：只要这个湖北籍的合租室友返回出租房，自己立马要求退租，不知面对这样的场景时，作为一个湖北籍的租客作何感想。</p><p>疫情还没有结束的时候，你们嘴里一个个喊着武汉加油、湖北加油、中国加油，可当疫情真的差不多快结束时，湖北人好不容易从封闭的环境中走出来，其中的一些人迎接他们的不是欢迎，也不是鼓励，却是恶狠狠的歧视。这一刻不知湖北人该是伤心还是寒心。</p><p>湖北物理上的道路封锁虽然已经解开，部分人心底对湖北人的枷锁、歧视却远远没有一丝丝松开的迹象。如果此刻你的身边有湖北省，那么请你从你做起，公平善待每一个遭遇过苦难的湖北人吧，病毒虽无情，但我坚信人家却有爱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​今天是2020年4月8日，历史将会铭记这个特殊的日子。经过整整76天漫长的等待之后，湖北省武汉市终于打开了尘封许久的通道大门，这意味着从今天开始，整个湖北省都将有序放开省内省外人员流动限制，从这这点而言，以湖北为重灾区的疫情主战场已经取得了重大的胜利，真正达到了总书记所强调的武汉胜则湖北胜，湖北胜则全国胜的要求。然而有时候物理上的解封还相对容易，可如何消除湖北省以外，各地居民心底上的枷锁、戒备却还是个值得研究的重要命题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="公众号文章" scheme="https://kkcl.github.io/categories/%E5%85%AC%E4%BC%97%E5%8F%B7%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="wechat" scheme="https://kkcl.github.io/tags/wechat/"/>
    
  </entry>
  
</feed>
